// --- START CHUNK: AIFlow.Cli.csproj.txt ---// --- START CHUNK: Program.cs ---using System.CommandLine;using System.CommandLine.Builder;using System.CommandLine.Parsing;using System.Globalization;using System.Reflection;using System.Resources;using AIFlow.Cli.Commands;public class Program{private static ResourceManager? _resourceManager;public static string GetLocalizedString(string key, params object[] args)
{
    _resourceManager ??= new ResourceManager("AIFlow.Cli.Properties.Resources", Assembly.GetExecutingAssembly());
    CultureInfo culture = CultureInfo.CurrentUICulture;
    try 
    { 
        string? format = _resourceManager.GetString(key, culture); 
        if (format == null) return $"[{key}]"; // Fallback if key not found
        return args.Length > 0 ? string.Format(culture, format, args) : format; 
    }
    catch (MissingManifestResourceException)
    {
        // Fallback for environments where resources might not be found
        if (key == "CliDescription") return "AIFlow CLI - Manages collaborative workflows with AI (fallback).";
        // Console.Error.WriteLine($"Warning: Resource manifest for 'AIFlow.Cli.Properties.Resources' not found. Using fallback for key '{key}'.");
        return $"[[MissingResources:{key}]]";
    }
    catch (Exception ex) 
    { 
        Console.Error.WriteLine($"Warning: Error loading localized string for key '{key}': {ex.Message}"); 
        return $"[[ErrorLoadingResource:{key}]]"; 
    }
}

public static async Task<int> Main(string[] args)
{
    var rootCommand = new RootCommand(GetLocalizedString("CliDescription"));
    rootCommand.AddCommand(InitCommand.Create());
    rootCommand.AddCommand(PrepareInputCommand.Create());
    rootCommand.AddCommand(IntegrateOutputCommand.Create());
    rootCommand.AddCommand(FetchOutputCommand.Create());
    rootCommand.AddCommand(StatusCommand.Create());
    rootCommand.AddCommand(BranchCommand.Create());
    rootCommand.AddCommand(CheckoutCommand.Create());
    rootCommand.AddCommand(TaskCommand.Create());
    rootCommand.AddCommand(ResolveCommand.Create()); 
    rootCommand.AddCommand(RevertIntegrationCommand.Create()); 
    rootCommand.AddCommand(SummaryCommand.Create()); 

    var commandLineBuilder = new CommandLineBuilder(rootCommand);
    commandLineBuilder.UseDefaults();
    var parser = commandLineBuilder.Build();
    return await parser.InvokeAsync(args);
}
}// --- END CHUNK: Program.cs ---// --- START CHUNK: Models/AIFlowFile.cs ---namespace AIFlow.Cli.Models{using System.Collections.Generic;using System;public class AIFlowFile
{
    public string ProjectName { get; set; } = "MyAIFlowProject";
    public string CurrentVersion { get; set; } = "0.1.0";
    public string CurrentBranch { get; set; } = "develop";
    public int NextTaskId { get; set; } = 1;
    public int NextHumanRequestGroupId { get; set; } = 101;
    public AIFlowConfigSettings Config { get; set; } = new();
    public List<AIFlowResource> Resources { get; set; } = new(); 
    public List<AIFlowTask> Tasks { get; set; } = new();
    public List<string> Roadmap { get; set; } = new(); 
    public ActiveRetrievalSession? ActiveAiRetrievalSession { get; set; }
}

public class AIFlowConfigSettings 
{ 
    public long MaxRequestPayloadSizeBytes { get; set; } = 500 * 1024; 
    public long MaxAiSingleMessageSizeBytes { get; set; } = 500 * 1024; 
    public int ApproxMaxAiContextTokens { get; set; } = 8000; 
}

public class AIFlowResource 
{ 
    public string Path { get; set; } = string.Empty; 
    public string Type { get; set; } = ResourceType.LocalFile; 
    public string LocalHash { get; set; } = string.Empty; 
    public string? LastSentToAiHash { get; set; } 
    public string Status { get; set; } = ResourceStatus.Unmodified;
    public string? ConflictResolutionFile { get; set; } 
    public string? Notes {get; set;} 
}

public static class ResourceType
{
    public const string LocalFile = "LocalFile";
    public const string URL = "URL";
    public const string TextSnippet = "TextSnippet"; 
}

public static class ResourceStatus 
{ 
    public const string Unmodified = "unmodified"; 
    public const string ModifiedLocally = "modified_locally"; 
    public const string AwaitingAiChanges = "awaiting_ai_changes"; 
    public const string AiModified = "ai_modified"; 
    public const string NeedsManualMerge = "needs_manual_merge"; 
    public const string Merged = "merged"; 
}

public class AIFlowTask 
{ 
    public string TaskId { get; set; } = string.Empty; 
    public string Branch { get; set; } = "develop"; 
    public string Description { get; set; } = string.Empty; 
    public string Status { get; set; } = TaskStatus.ToDo; 
    public string AssignedTo { get; set; } = "ai"; 
    public List<AIFlowTaskRelatedResource> RelatedResources { get; set; } = new(); 
    public string? HumanRequestGroupId { get; set; } 
    public int? HumanRequestTotalParts { get; set; } 
    public int HumanRequestPartsSent { get; set; } = 0; 
    public string? HumanNotes { get; set; } 
    public string? AiNotes { get; set; } 
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow; 
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow; 
    public string? Type { get; set; } 
    public int? StoryPoints { get; set; } 
    public string? Priority { get; set; } 
    public string? Sprint { get; set; } 
    public string? EpicLink { get; set; } 
    public DateTime? DueDate { get; set; } 
    public List<string> Labels { get; set; } = new(); 
} 

public static class TaskStatus 
{ 
    public const string ToDo = "todo"; 
    public const string InProgress = "in_progress"; 
    public const string PendingHumanInput = "pending_human_input"; 
    public const string PendingHumanInputParts = "pending_human_input_parts"; 
    public const string PendingAiProcessing = "pending_ai_processing"; 
    public const string Blocked = "blocked"; 
    public const string InReview = "in_review"; 
    public const string PendingHumanReview = "pending_human_review"; 
    public const string Done = "done"; 
    public const string Completed = "completed"; 
    public const string Failed = "failed"; 
    public const string AwaitingAiBatches = "awaiting_ai_batches"; 
    public const string Archived = "archived"; 
} 

public static class TaskType 
{ 
    public const string Story = "Story"; 
    public const string Task = "Task"; 
    public const string Bug = "Bug"; 
    public const string Epic = "Epic"; 
    public const string Spike = "Spike"; 
} 

public static class TaskPriority 
{ 
    public const string Highest = "Highest"; 
    public const string High = "High"; 
    public const string Medium = "Medium"; 
    public const string Low = "Low"; 
    public const string Lowest = "Lowest"; 
} 

public class AIFlowTaskRelatedResource 
{ 
    public string Path { get; set; } = string.Empty; 
    public string Type { get; set; } = ResourceType.LocalFile; 
    public int? SentInPart { get; set; } 
    public string Action { get; set; } = "update"; 
    public string? HashAtRequestTime { get; set; } 
    public string? ContentDetail { get; set; } 
} 

public class ActiveRetrievalSession 
{ 
    public string RetrievalGuid { get; set; } = string.Empty; 
    public string AiChangesetId { get; set; } = string.Empty; 
    public int TotalBatches { get; set; } 
    public int ReceivedBatchesCount { get; set; } 
    public List<string> ReceivedBatchPayloads { get; set; } = new(); 
} 
}// --- END CHUNK: Models/AIFlowFile.cs ---// --- START CHUNK: Models/BackupInfo.cs ---namespace AIFlow.Cli.Models{using System;using System.Collections.Generic;public class BackupInfo
{
    public string BackupId { get; set; } = string.Empty; 
    public DateTime TimestampUtc { get; set; }
    public string? RelatedTaskId { get; set; }
    public string? AiChangesetId { get; set; }
    public List<string> BackedUpFileRelativePaths { get; set; } = new List<string>();
    public string Notes { get; set; } = string.Empty;
}
}// --- END CHUNK: Models/BackupInfo.cs ---// --- START CHUNK: Models/FlowTemplate.cs ---namespace AIFlow.Cli.Models{using System.Collections.Generic;public class FlowTemplateCollection
{
    public List<FlowTemplate> Templates { get; set; } = new List<FlowTemplate>();
}

public class FlowTemplate
{
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public AIFlowConfigSettings? ConfigOverrides { get; set; } 
    public List<AIFlowTaskStub> InitialTasks { get; set; } = new List<AIFlowTaskStub>();
    public List<InitialResourceStub> InitialResources { get; set; } = new List<InitialResourceStub>();
    public List<string> InitialRoadmap { get; set; } = new List<string>();
}

public class AIFlowTaskStub
{
    public string? TaskId { get; set; } 
    public string Description { get; set; } = string.Empty;
    public string? Branch { get; set; } 
    public string? Status { get; set; } 
    public string? AssignedTo { get; set; }
    public string? Type { get; set; }
    public int? StoryPoints { get; set; }
    public string? Priority { get; set; }
    public string? Sprint { get; set; }
    public string? EpicLink { get; set; }
    public string? DueDate { get; set; } 
    public List<string>? Labels { get; set; }
    public string? HumanNotes { get; set; }
    public List<AIFlowTaskRelatedResourceStub>? RelatedResources { get; set; }
}

public class AIFlowTaskRelatedResourceStub
{
    public string Path { get; set; } = string.Empty;
    public string Type { get; set; } = ResourceType.LocalFile;
    public string Action { get; set; } = "create"; 
}

public class InitialResourceStub
{
    public string Path { get; set; } = string.Empty;
    public string Type { get; set; } = ResourceType.LocalFile;
    public string? InitialContent { get; set; } 
    public string? Status { get; set; } 
    public string? Notes { get; set; }
}
}// --- END CHUNK: Models/FlowTemplate.cs ---// --- START CHUNK: Services/AIFlowConfigService.cs ---namespace AIFlow.Cli.Services{using AIFlow.Cli.Models;using System.Text.Json;using System.IO;using System;public static class AIFlowConfigService
{
    public static readonly string ConfigFileName = "aiflow.json";
    private static readonly JsonSerializerOptions JsonOptions = new() 
    { 
        WriteIndented = true, 
        PropertyNameCaseInsensitive = true, 
        DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull 
    };

    public static AIFlowFile? LoadConfig(string path = ".")
    {
        var configPath = Path.Combine(path, ConfigFileName);
        if (!File.Exists(configPath))
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorConfigNotFound", ConfigFileName, Path.GetFullPath(path)));
            return null;
        }
        try
        {
            var json = File.ReadAllText(configPath);
            return JsonSerializer.Deserialize<AIFlowFile>(json, JsonOptions);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorParsingConfig", ConfigFileName, ex.Message));
            return null;
        }
    }

    public static bool SaveConfig(AIFlowFile config, string path = ".")
    {
        var configPath = Path.Combine(path, ConfigFileName);
        try
        {
            var json = JsonSerializer.Serialize(config, JsonOptions);
            File.WriteAllText(configPath, json);
            return true;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorSavingConfig", ConfigFileName, ex.Message));
            return false;
        }
    }
}
}// --- END CHUNK: Services/AIFlowConfigService.cs ---// --- START CHUNK: Services/FileService.cs ---namespace AIFlow.Cli.Services{using System.Security.Cryptography;using System.Text;using System;using System.IO;public static class FileService
{
    public static string? CalculateFileHash(string filePath)
    {
        if (!File.Exists(filePath))
        {
            return null;
        }
        try
        {
            using var sha256 = SHA256.Create();
            using var stream = File.OpenRead(filePath);
            var hashBytes = sha256.ComputeHash(stream);
            return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorCalculatingHash", filePath, ex.Message));
            return null;
        }
    }

    public static string Base64Encode(string plainText) => Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));
    
    public static string Base64Decode(string base64EncodedData)
    {
        try 
        {
            return Encoding.UTF8.GetString(Convert.FromBase64String(base64EncodedData));
        }
        catch (FormatException ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorDecodingBase64", ex.Message));
            return string.Empty; 
        }
    }

    public static string GetProjectRelativePath(string fullPath)
    {
        string currentDirectory = Directory.GetCurrentDirectory();
        if (!currentDirectory.EndsWith(Path.DirectorySeparatorChar.ToString()) && !currentDirectory.EndsWith(Path.AltDirectorySeparatorChar.ToString()))
        {
            currentDirectory += Path.DirectorySeparatorChar;
        }
        Uri projectUri = new Uri(currentDirectory);
        Uri fileUri = new Uri(Path.GetFullPath(fullPath)); 

        if (projectUri.IsBaseOf(fileUri))
        {
             return Uri.UnescapeDataString(projectUri.MakeRelativeUri(fileUri).ToString().Replace(Path.DirectorySeparatorChar, '/'));
        }
        return fullPath.Replace(Path.DirectorySeparatorChar, '/');
    }
    
    public static string GetFullPath(string projectRelativePath)
    {
        return Path.GetFullPath(projectRelativePath.Replace('/', Path.DirectorySeparatorChar));
    }
}
}// --- END CHUNK: Services/FileService.cs ---// --- START CHUNK: Services/IgnoreService.cs ---namespace AIFlow.Cli.Services{using Microsoft.Extensions.FileSystemGlobbing;using System.Collections.Generic;using System.IO;using System.Linq;using System;public static class IgnoreService
{
    public const string IgnoreFileName = ".aiflowignore";

    private static readonly List<string> DefaultIgnorePatterns = new List<string>
    {
        BackupService.BackupsDirectoryName + "/", 
        ".git/",
        ".vs/",
        ".vscode/",
        "bin/",
        "obj/",
        "**/bin/", 
        "**/obj/",
        "*.lock",
        "*.suo",
        "*.user",
        AIFlowConfigService.ConfigFileName 
    };

    public static Matcher LoadIgnoreMatcher(string projectRootPath)
    {
        var matcher = new Matcher(StringComparison.OrdinalIgnoreCase); 
        foreach(var p in DefaultIgnorePatterns) {
             matcher.AddExclude(p);
        }

        var ignoreFilePath = Path.Combine(projectRootPath, IgnoreFileName);
        if (File.Exists(ignoreFilePath))
        {
            var patterns = File.ReadAllLines(ignoreFilePath)
                .Select(line => line.Trim())
                .Where(line => !string.IsNullOrWhiteSpace(line) && !line.StartsWith("#"))
                .ToList();
            
            foreach(var pattern in patterns)
            {
                if (pattern.StartsWith("!")) 
                {
                    matcher.AddInclude(pattern.Substring(1));
                }
                else
                {
                    matcher.AddExclude(pattern);
                }
            }
        }
        return matcher;
    }

    public static bool IsFileIgnored(string relativeFilePath, Matcher matcher)
    {
        var normalizedPath = relativeFilePath.Replace(Path.DirectorySeparatorChar, '/');
        var result = matcher.Match(normalizedPath); 
        return result.HasMatches;
    }

     public static bool IsFileIgnored(string relativeFilePath, string projectRootPath)
    {
        var matcher = LoadIgnoreMatcher(projectRootPath);
        return IsFileIgnored(relativeFilePath, matcher);
    }
}
}// --- END CHUNK: Services/IgnoreService.cs ---// --- START CHUNK: Services/BackupService.cs ---namespace AIFlow.Cli.Services{using AIFlow.Cli.Models;using System.Text.Json;using System;using System.IO;using System.Collections.Generic;using System.Linq;public static class BackupService
{
    public const string BackupsDirectoryName = ".aiflow_backups";
    private const string BackupInfoFileName = "backup_info.json";
    private static readonly JsonSerializerOptions JsonOptions = new() { WriteIndented = true };

    public static string CreateBackup(AIFlowFile currentConfig, List<string> filesToBackupRelativePaths, string? relatedTaskId, string? aiChangesetId)
    {
        var timestamp = DateTime.UtcNow;
        var backupId = timestamp.ToString("yyyyMMddHHmmssfff");
        var backupDir = Path.Combine(Directory.GetCurrentDirectory(), BackupsDirectoryName, backupId);

        try
        {
            Directory.CreateDirectory(backupDir);

            var currentConfigPath = Path.Combine(Directory.GetCurrentDirectory(), AIFlowConfigService.ConfigFileName);
            if (File.Exists(currentConfigPath)) 
            {
                 File.Copy(currentConfigPath, Path.Combine(backupDir, AIFlowConfigService.ConfigFileName), true);
            }

            var backedUpFilePathsInBackupDir = new List<string>();
            foreach (var relativePath in filesToBackupRelativePaths)
            {
                var sourceFullPath = FileService.GetFullPath(relativePath);
                if (File.Exists(sourceFullPath))
                {
                    var cleanRelativePath = relativePath.TrimStart(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
                    var destPathInBackup = Path.Combine(backupDir, "files", cleanRelativePath); 
                    Directory.CreateDirectory(Path.GetDirectoryName(destPathInBackup)!);
                    File.Copy(sourceFullPath, destPathInBackup, true);
                    backedUpFilePathsInBackupDir.Add(cleanRelativePath);
                }
            }

            var backupInfo = new BackupInfo
            {
                BackupId = backupId,
                TimestampUtc = timestamp,
                RelatedTaskId = relatedTaskId,
                AiChangesetId = aiChangesetId,
                BackedUpFileRelativePaths = backedUpFilePathsInBackupDir,
                Notes = $"Backup before integrating AI changes for task '{relatedTaskId ?? "N/A"}'."
            };
            File.WriteAllText(Path.Combine(backupDir, BackupInfoFileName), JsonSerializer.Serialize(backupInfo, JsonOptions));
            
            Console.WriteLine(Program.GetLocalizedString("BackupCreatedSuccessfully", backupId, backupDir));
            return backupId;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorCreatingBackup", backupId, ex.Message));
            if (Directory.Exists(backupDir)) try { Directory.Delete(backupDir, true); } catch {}
            return string.Empty;
        }
    }

    public static List<BackupInfo> ListBackups()
    {
        var backups = new List<BackupInfo>();
        var rootBackupDir = Path.Combine(Directory.GetCurrentDirectory(), BackupsDirectoryName);
        if (!Directory.Exists(rootBackupDir)) return backups;

        foreach (var dir in Directory.GetDirectories(rootBackupDir))
        {
            var infoFilePath = Path.Combine(dir, BackupInfoFileName);
            if (File.Exists(infoFilePath))
            {
                try
                {
                    var info = JsonSerializer.Deserialize<BackupInfo>(File.ReadAllText(infoFilePath), JsonOptions);
                    if (info != null) backups.Add(info);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(Program.GetLocalizedString("ErrorReadingBackupInfo", Path.GetFileName(dir), ex.Message));
                }
            }
        }
        return backups.OrderByDescending(b => b.TimestampUtc).ToList();
    }

    public static bool RestoreBackup(string backupId)
    {
        var backupDir = Path.Combine(Directory.GetCurrentDirectory(), BackupsDirectoryName, backupId);
        var backupInfoFilePath = Path.Combine(backupDir, BackupInfoFileName);

        if (!Directory.Exists(backupDir) || !File.Exists(backupInfoFilePath))
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorBackupNotFound", backupId));
            return false;
        }

        try
        {
            var backupInfo = JsonSerializer.Deserialize<BackupInfo>(File.ReadAllText(backupInfoFilePath), JsonOptions);
            if (backupInfo == null)
            {
                Console.Error.WriteLine(Program.GetLocalizedString("ErrorInvalidBackupInfo", backupId));
                return false;
            }

            var backupConfigPath = Path.Combine(backupDir, AIFlowConfigService.ConfigFileName);
            var targetConfigPath = Path.Combine(Directory.GetCurrentDirectory(), AIFlowConfigService.ConfigFileName);
            if (File.Exists(backupConfigPath)) {
                File.Copy(backupConfigPath, targetConfigPath, true);
                Console.WriteLine(Program.GetLocalizedString("RestoredFile", AIFlowConfigService.ConfigFileName, backupId));
            } else {
                 Console.Error.WriteLine(Program.GetLocalizedString("WarningFileNotFoundInBackup", AIFlowConfigService.ConfigFileName, backupId));
            }

            foreach (var relativePath in backupInfo.BackedUpFileRelativePaths)
            {
                var sourcePathInBackup = Path.Combine(backupDir, "files", relativePath);
                var targetPathInProject = FileService.GetFullPath(relativePath);

                if (File.Exists(sourcePathInBackup))
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(targetPathInProject)!);
                    File.Copy(sourcePathInBackup, targetPathInProject, true);
                    Console.WriteLine(Program.GetLocalizedString("RestoredFile", relativePath, backupId));
                }
                else
                {
                    Console.Error.WriteLine(Program.GetLocalizedString("WarningFileNotFoundInBackup", relativePath, backupId));
                }
            }
            
            Console.WriteLine(Program.GetLocalizedString("RestoreCompletedSuccessfully", backupId));
            Console.WriteLine(Program.GetLocalizedString("RestoreNextSteps"));
            return true;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("ErrorDuringRestore", backupId, ex.Message));
            return false;
        }
    }
}
}// --- END CHUNK: Services/BackupService.cs ---// --- START CHUNK: Services/JsonPayloadModels.cs ---namespace AIFlow.Cli.Services.Payloads{using System.Collections.Generic;using System;public class HumanRequestPart { public HumanRequestPayload HumanRequest { get; set; } = new(); } 
public class HumanRequestPayload { public string? HumanRequestGroupId { get; set; } public int PartNumber { get; set; } public int TotalParts { get; set; } public string TaskId { get; set; } = string.Empty; public string? TaskDescription { get; set; } public List<HumanRequestFileToProcess>? FilesToProcess { get; set; }  public List<HumanRequestFileData>? FileData { get; set; } public object? RelevantMetadata { get; set; } } 
public class HumanRequestFileToProcess { public string Path { get; set; } = string.Empty; public string Action { get; set; } = string.Empty;  public string? Hash { get; set; } public string? ContentBase64 { get; set; } public string? ContentDetail { get; set; } } 
public class HumanRequestFileData { public string Path { get; set; } = string.Empty; public string ContentBase64 { get; set; } = string.Empty; } 
public class AiPreliminaryResponseWrapper { public AiPreliminaryResponse AiPreliminaryResponse { get; set; } = new(); } 
public class AiPreliminaryResponse { public string AiChangesetId { get; set; } = string.Empty; public string HumanRequestId { get; set; } = string.Empty;  public string Status { get; set; } = string.Empty;  public long? EstimatedTotalSizeBytes { get; set; } public int NumberOfBatches { get; set; } public string RetrievalGuid { get; set; } = string.Empty; public string? InstructionsForCli { get; set; } } 
public class AiOutputPackageWrapper { public AiOutputPackage AiOutputPackage { get; set; } = new(); } 
public class AiBatchResponseWrapper { public AiBatchResponse AiBatchResponse { get; set; } = new(); } 
public class AiOutputPackage  { public string AiChangesetId { get; set; } = string.Empty; public string HumanRequestId { get; set; } = string.Empty; public AiTaskUpdate? TaskUpdates { get; set; } public List<AiFileChange>? FileChanges { get; set; } public List<string>? RoadmapSuggestions { get; set; } public string? OverallAiComment { get; set; } public string? RetrievalGuid { get; set; }  public int? BatchNumber { get; set; } public int? TotalBatches { get; set; } public bool? IsLastBatch {get; set;}  } 
public class AiBatchResponse { public string RetrievalGuid { get; set; } = string.Empty; public string AiChangesetId { get; set; } = string.Empty; public int BatchNumber { get; set; } public int TotalBatches { get; set; } public bool IsLastBatch { get; set; } public string PayloadType { get; set; } = string.Empty;  public AiOutputPackage Payload { get; set; } = new();  } 
public class AiTaskUpdate { public string TaskId { get; set; } = string.Empty; public string NewStatus { get; set; } = string.Empty; public string? AiNotes { get; set; } public DateTime? UpdatedAt { get; set; } } 
public class AiFileChange { public string Path { get; set; } = string.Empty; public string Action { get; set; } = string.Empty;  public string? NewHash { get; set; }  public string? BasedOnHash { get; set; }  public string? ContentBase64 { get; set; }  public string? ContentDelivery { get; set; } public int? TotalContentChunksForFile { get; set; }  public int? ChunkNumberForFile {get; set;} } 
}// --- END CHUNK: Services/JsonPayloadModels.cs ---// --- START CHUNK: Commands/InitCommand.cs ---namespace AIFlow.Cli.Commands{using System.CommandLine;using System.CommandLine.Invocation;using AIFlow.Cli.Models;using AIFlow.Cli.Services;using System.IO;using System;using System.Text.Json;using System.Linq;using System.Collections.Generic;public static class InitCommand 
{ 
    static Option<string?> templateNameOption = new Option<string?>(
        aliases: new[] { "--template", "-t" },
        description: Program.GetLocalizedString("InitTemplateNameOptionDescription"));

    static Option<string?> templateFileOption = new Option<string?>(
        aliases: new[] { "--template-file" },
        getDefaultValue: () => "aiflow_templates.json",
        description: Program.GetLocalizedString("InitTemplateFileOptionDescription"));

    public static Command Create() 
    { 
        var command = new Command("init", Program.GetLocalizedString("InitCommandDescription")); 
        command.AddOption(templateNameOption);
        command.AddOption(templateFileOption);

        command.SetHandler((InvocationContext context) => 
        { 
            var templateName = context.ParseResult.GetValueForOption(templateNameOption);
            var templateFilePath = context.ParseResult.GetValueForOption(templateFileOption);
            HandleInit(templateName, templateFilePath);
        }); 
        return command; 
    } 

    private static void HandleInit(string? templateName, string? templateFilePath)
    {
        Console.WriteLine(Program.GetLocalizedString("InitializingAIFlowProject")); 
        var projectRoot = Directory.GetCurrentDirectory(); 
        var configFilePath = Path.Combine(projectRoot, AIFlowConfigService.ConfigFileName); 

        if (File.Exists(configFilePath)) 
        { 
            Console.WriteLine(Program.GetLocalizedString("AIFlowProjectAlreadyExists", AIFlowConfigService.ConfigFileName)); 
            return; 
        } 

        AIFlowFile aiflowConfig;

        if (!string.IsNullOrEmpty(templateName) && !string.IsNullOrEmpty(templateFilePath))
        {
            aiflowConfig = LoadFromTemplate(projectRoot, templateName, templateFilePath);
            if (aiflowConfig == null)
            {
                Console.WriteLine(Program.GetLocalizedString("InitFallingBackToDefault"));
                aiflowConfig = new AIFlowFile { ProjectName = Path.GetFileName(projectRoot) ?? "MyAIFlowProject" };
            } else {
                Console.WriteLine(Program.GetLocalizedString("InitAppliedTemplate", templateName));
            }
        }
        else
        {
            aiflowConfig = new AIFlowFile { ProjectName = Path.GetFileName(projectRoot) ?? "MyAIFlowProject" };
        }

        if (AIFlowConfigService.SaveConfig(aiflowConfig, projectRoot)) 
        { 
            Console.WriteLine(Program.GetLocalizedString("AIFlowProjectInitialized", AIFlowConfigService.ConfigFileName)); 
            Console.WriteLine(Program.GetLocalizedString("DefaultBranchIsDevelop")); 
            
            var ignoreFilePath = Path.Combine(projectRoot, IgnoreService.IgnoreFileName); 
            if (!File.Exists(ignoreFilePath)) 
            { 
                try 
                { 
                    File.WriteAllText(ignoreFilePath, Program.GetLocalizedString("SampleAIFlowIgnoreContent")); 
                    Console.WriteLine(Program.GetLocalizedString("SampleAIFlowIgnoreCreated", IgnoreService.IgnoreFileName)); 
                } 
                catch (Exception ex) 
                { 
                    Console.Error.WriteLine(Program.GetLocalizedString("ErrorCreatingSampleIgnoreFile", IgnoreService.IgnoreFileName, ex.Message)); 
                } 
            } 
        } 
        else 
        { 
            Console.Error.WriteLine(Program.GetLocalizedString("FailedToInitializeAIFlowProject")); 
        } 
    }

    private static AIFlowFile? LoadFromTemplate(string projectRoot, string templateName, string templateFilePath)
    {
        string fullTemplatePath = Path.GetFullPath(templateFilePath);
        if (!File.Exists(fullTemplatePath))
        {
            Console.Error.WriteLine(Program.GetLocalizedString("InitErrorTemplateFileNotFound", templateFilePath));
            return null;
        }

        try
        {
            var templateJson = File.ReadAllText(fullTemplatePath);
            var templateCollection = JsonSerializer.Deserialize<FlowTemplateCollection>(templateJson, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            
            var selectedTemplate = templateCollection?.Templates.FirstOrDefault(t => t.Name.Equals(templateName, StringComparison.OrdinalIgnoreCase));
            if (selectedTemplate == null)
            {
                Console.Error.WriteLine(Program.GetLocalizedString("InitErrorTemplateNotFoundInFile", templateName, templateFilePath));
                return null;
            }

            var newConfig = new AIFlowFile
            {
                ProjectName = Path.GetFileName(projectRoot) ?? $"ProjectFrom_{templateName}",
                CurrentBranch = "develop", // Default, can be overridden by template.ConfigOverrides
                Roadmap = new List<string>(selectedTemplate.InitialRoadmap ?? Enumerable.Empty<string>()),
                Config = new AIFlowConfigSettings(), 
                NextTaskId = 1, 
                NextHumanRequestGroupId = 101 
            };

            if (selectedTemplate.ConfigOverrides != null)
            {
                if(!string.IsNullOrEmpty(selectedTemplate.ConfigOverrides.CurrentBranch)) newConfig.CurrentBranch = selectedTemplate.ConfigOverrides.CurrentBranch;
                if(selectedTemplate.ConfigOverrides.MaxRequestPayloadSizeBytes > 0) newConfig.Config.MaxRequestPayloadSizeBytes = selectedTemplate.ConfigOverrides.MaxRequestPayloadSizeBytes;
                if(selectedTemplate.ConfigOverrides.MaxAiSingleMessageSizeBytes > 0) newConfig.Config.MaxAiSingleMessageSizeBytes = selectedTemplate.ConfigOverrides.MaxAiSingleMessageSizeBytes;
                if(selectedTemplate.ConfigOverrides.ApproxMaxAiContextTokens > 0) newConfig.Config.ApproxMaxAiContextTokens = selectedTemplate.ConfigOverrides.ApproxMaxAiContextTokens;
            }

            int taskIdCounter = newConfig.NextTaskId;
            foreach (var taskStub in selectedTemplate.InitialTasks)
            {
                var newTask = new AIFlowTask
                {
                    TaskId = taskStub.TaskId ?? $"task_{taskIdCounter++}",
                    Description = taskStub.Description,
                    Branch = taskStub.Branch ?? newConfig.CurrentBranch,
                    Status = taskStub.Status ?? TaskStatus.ToDo,
                    AssignedTo = taskStub.AssignedTo ?? "ai",
                    Type = taskStub.Type, 
                    StoryPoints = taskStub.StoryPoints,
                    Priority = taskStub.Priority,
                    Sprint = taskStub.Sprint,
                    EpicLink = taskStub.EpicLink,
                    DueDate = !string.IsNullOrEmpty(taskStub.DueDate) && DateTime.TryParse(taskStub.DueDate, out var dt) ? dt : (DateTime?)null,
                    Labels = taskStub.Labels?.ToList() ?? new List<string>(),
                    HumanNotes = taskStub.HumanNotes,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow,
                    RelatedResources = new List<AIFlowTaskRelatedResource>()
                };
                if (taskStub.RelatedResources != null)
                {
                    foreach(var resStub in taskStub.RelatedResources)
                    {
                        newTask.RelatedResources.Add(new AIFlowTaskRelatedResource { Path = resStub.Path, Type = resStub.Type, Action = resStub.Action });
                    }
                }
                newConfig.Tasks.Add(newTask);
            }
            newConfig.NextTaskId = taskIdCounter;

            foreach (var resourceStub in selectedTemplate.InitialResources)
            {
                var newResource = new AIFlowResource
                {
                    Path = resourceStub.Path,
                    Type = resourceStub.Type,
                    Status = resourceStub.Status ?? ResourceStatus.Unmodified,
                    Notes = resourceStub.Notes
                };
                if (resourceStub.Type == ResourceType.LocalFile && !string.IsNullOrEmpty(resourceStub.Path))
                {
                    var fullResourcePath = FileService.GetFullPath(Path.Combine(projectRoot, resourceStub.Path)); // Ensure path is relative to project root
                    try
                    {
                        Directory.CreateDirectory(Path.GetDirectoryName(fullResourcePath)!);
                        File.WriteAllText(fullResourcePath, resourceStub.InitialContent ?? $"# Placeholder for {resourceStub.Path}{Environment.NewLine}");
                        newResource.LocalHash = FileService.CalculateFileHash(fullResourcePath) ?? string.Empty;
                        Console.WriteLine(Program.GetLocalizedString("InitCreatedPlaceholderResource", resourceStub.Path));
                    }
                    catch (Exception ex)
                    {
                        Console.Error.WriteLine(Program.GetLocalizedString("InitErrorCreatingPlaceholderResource", resourceStub.Path, ex.Message));
                    }
                }
                newConfig.Resources.Add(newResource);
            }
            return newConfig;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(Program.GetLocalizedString("InitErrorProcessingTemplateFile", templateFilePath, ex.Message));
            return null;
        }
    }
} 
}// --- END CHUNK: Commands/InitCommand.cs ---// --- START CHUNK: Commands/PrepareInputCommand.cs ---namespace AIFlow.Cli.Commands{using System.CommandLine;using System.CommandLine.Invocation;using AIFlow.Cli.Models;using AIFlow.Cli.Services;using AIFlow.Cli.Services.Payloads;using System.Text;using System.Text.Json;using Microsoft.Extensions.FileSystemGlobbing;using System.IO;using System.Threading.Tasks;using System.Collections.Generic;using System.Linq;using System;public static class PrepareInputCommand 
{ 
    static Option<string?> taskIdOption = new Option<string?>(aliases: new[] { "--task-id", "-tid" }, description: Program.GetLocalizedString("PrepareInputTaskIdOptionDescription")); 
    static Option<string?> taskDescOption = new Option<string?>(aliases: new[] { "--task-desc", "-td" }, description: Program.GetLocalizedString("PrepareInputTaskDescOptionDescription")); 
    static Option<string[]?> resourcesOption = new Option<string[]?>(aliases: new[] { "--resource", "-r" }, description: Program.GetLocalizedString("PrepareInputResourceOptionDescription")) { Arity = ArgumentArity.ZeroOrMore }; 
    static Option<string[]?> newResourcesOption = new Option<string[]?>(aliases: new[] { "--new-resource", "-nr" }, description: Program.GetLocalizedString("PrepareInputNewResourceOptionDescription")) { Arity = ArgumentArity.ZeroOrMore }; 
    static Option<string?> continueTaskOption = new Option<string?>(aliases: new[] { "--continue-task" }, description: Program.GetLocalizedString("PrepareInputContinueTaskOptionDescription")); 
    static Option<string?> typeOption = new Option<string?>(aliases: new[] { "--type" }, description: Program.GetLocalizedString("PrepareInputTypeOptionDescription_Optional"), parseArgument: result => { if (!result.Tokens.Any()) return null; var typeVal = result.Tokens.Single().Value; var validTypes = new[] { TaskType.Story, TaskType.Task, TaskType.Bug, TaskType.Epic, TaskType.Spike }; if (!validTypes.Contains(typeVal, StringComparer.OrdinalIgnoreCase)) { result.ErrorMessage = Program.GetLocalizedString("ErrorInvalidTaskType", typeVal, string.Join(", ", validTypes)); return null; } return validTypes.First(vt => vt.Equals(typeVal, StringComparer.OrdinalIgnoreCase)); }); 
    static Option<int?> storyPointsOption = new Option<int?>(aliases: new[] { "--story-points", "-sp" }, description: Program.GetLocalizedString("PrepareInputStoryPointsOptionDescription")); 
    static Option<string?> priorityOption = new Option<string?>(aliases: new[] { "--priority", "-p" }, description: Program.GetLocalizedString("PrepareInputPriorityOptionDescription_Optional"), parseArgument: result => { if (!result.Tokens.Any()) return null; var prioVal = result.Tokens.Single().Value; var validPrios = new[] { TaskPriority.Highest, TaskPriority.High, TaskPriority.Medium, TaskPriority.Low, TaskPriority.Lowest }; if (!validPrios.Contains(prioVal, StringComparer.OrdinalIgnoreCase)) { result.ErrorMessage = Program.GetLocalizedString("ErrorInvalidTaskPriority", prioVal, string.Join(", ", validPrios)); return null; } return validPrios.First(vp => vp.Equals(prioVal, StringComparer.OrdinalIgnoreCase)); }); 
    static Option<string?> sprintOption = new Option<string?>(aliases: new[] { "--sprint" }, description: Program.GetLocalizedString("PrepareInputSprintOptionDescription")); 
    static Option<string?> epicLinkOption = new Option<string?>(aliases: new[] { "--epic-link" }, description: Program.GetLocalizedString("PrepareInputEpicLinkOptionDescription")); 
    static Option<DateTime?> dueDateOption = new Option<DateTime?>(aliases: new[] { "--due-date" }, description: Program.GetLocalizedString("PrepareInputDueDateOptionDescription")); 
    static Option<string[]?> labelsOption = new Option<string[]?>(aliases: new[] { "--labels", "-l" }, description: Program.GetLocalizedString("PrepareInputLabelsOptionDescription")) { Arity = ArgumentArity.ZeroOrMore }; 
    static Option<string?> assigneeOption = new Option<string?>(aliases: new[] { "--assignee" }, description: Program.GetLocalizedString("PrepareInputAssigneeOptionDescription")); 
    static Option<string?> branchOption = new Option<string?>(aliases: new[] { "--branch", "-b" }, description: Program.GetLocalizedString("PrepareInputBranchOptionDescription")); 
    static Option<string?> humanNotesOption = new Option<string?>(aliases: new[] { "--notes", "-n" }, description: Program.GetLocalizedString("PrepareInputHumanNotesOptionDescription")); 
    
    public static Command Create() { /* ... same as v1.7 ... */ var command = new Command("prepare-input", Program.GetLocalizedString("PrepareInputCommandDescription")); command.AddOption(taskIdOption); command.AddOption(taskDescOption); command.AddOption(resourcesOption); command.AddOption(newResourcesOption); command.AddOption(continueTaskOption); command.AddOption(typeOption); command.AddOption(storyPointsOption); command.AddOption(priorityOption); command.AddOption(sprintOption); command.AddOption(epicLinkOption); command.AddOption(dueDateOption); command.AddOption(labelsOption); command.AddOption(assigneeOption); command.AddOption(branchOption); command.AddOption(humanNotesOption); command.SetHandler(async (InvocationContext context) => { bool isInteractive = context.ParseResult.CommandResult.Children.Count == 0 || (context.ParseResult.HasOption(taskDescOption) && !context.ParseResult.HasOption(taskIdOption) && !context.ParseResult.HasOption(resourcesOption) && !context.ParseResult.HasOption(newResourcesOption) && !context.ParseResult.HasOption(continueTaskOption)); if (isInteractive && string.IsNullOrEmpty(context.ParseResult.GetValueForOption(continueTaskOption))) { await RunInteractiveMode(context); } else { await HandlePrepareInput(context, false); } }); return command; } 
    
    private static async Task RunInteractiveMode(InvocationContext context) { /* ... same as v1.7 ... */ Console.WriteLine(Program.GetLocalizedString("PrepareInputInteractiveModeStart")); var config = AIFlowConfigService.LoadConfig(); if (config == null) return; string? taskId = context.ParseResult.GetValueForOption(taskIdOption); string? taskDesc = context.ParseResult.GetValueForOption(taskDescOption); if (string.IsNullOrEmpty(taskDesc)) taskDesc = Prompt(Program.GetLocalizedString("PromptTaskDesc")); if (string.IsNullOrEmpty(taskDesc)) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorTaskDescRequired")); return; } var resources = PromptForMultiple(Program.GetLocalizedString("PromptResourcesToInclude"), Program.GetLocalizedString("PromptResourceToAttachPath")); var newResources = PromptForMultiple(Program.GetLocalizedString("PromptNewResourcesToCreate"), Program.GetLocalizedString("PromptNewResourcePath")); Console.WriteLine(Program.GetLocalizedString("PromptAgileDataOptional")); string? type = PromptOptional(Program.GetLocalizedString("PromptTaskType", string.Join(", ", TaskType.Story, TaskType.Task, TaskType.Bug, TaskType.Epic, TaskType.Spike))); int? storyPoints = PromptOptionalInt(Program.GetLocalizedString("PromptStoryPoints")); string? priority = PromptOptional(Program.GetLocalizedString("PromptTaskPriority", string.Join(", ", TaskPriority.Highest, TaskPriority.High, TaskPriority.Medium, TaskPriority.Low, TaskPriority.Lowest))); string? sprint = PromptOptional(Program.GetLocalizedString("PromptSprint")); string? epicLink = PromptOptional(Program.GetLocalizedString("PromptEpicLink")); DateTime? dueDate = PromptOptionalDate(Program.GetLocalizedString("PromptDueDate")); var labels = PromptForMultiple(Program.GetLocalizedString("PromptLabels"), Program.GetLocalizedString("PromptLabelToAdd")); string? assignee = PromptOptional(Program.GetLocalizedString("PromptAssignee"), "ai"); string? branch = PromptOptional(Program.GetLocalizedString("PromptBranch"), config.CurrentBranch); string? humanNotes = PromptOptional(Program.GetLocalizedString("PromptHumanNotes")); await HandlePrepareInputLogic( taskId, taskDesc, resources?.ToArray(), newResources?.ToArray(), null, type, storyPoints, priority, sprint, epicLink, dueDate, labels?.ToArray(), assignee, branch, humanNotes, context ); } 
    private static string? Prompt(string message, string? defaultValue = null) { /* ... same ... */ Console.Write($"{message}{(defaultValue == null ? "" : $" [{defaultValue}]")}: "); var input = Console.ReadLine(); return string.IsNullOrWhiteSpace(input) ? defaultValue : input.Trim(); } 
    private static string? PromptOptional(string message, string? defaultValue = null) { /* ... same ... */ var input = Prompt($"{message} (optional, press Enter to skip{(defaultValue == null ? "" : $" or use default '{defaultValue}'")})", defaultValue); return string.IsNullOrWhiteSpace(input) ? defaultValue : (input == defaultValue && string.IsNullOrWhiteSpace(Console.ReadLine()?.Trim()) ? defaultValue : input); } 
    private static int? PromptOptionalInt(string message) { /* ... same ... */ var input = PromptOptional(message); return int.TryParse(input, out int val) ? val : null; } 
    private static DateTime? PromptOptionalDate(string message) { /* ... same ... */ var input = PromptOptional(message + " (YYYY-MM-DD)"); return DateTime.TryParse(input, out DateTime val) ? val : null; } 
    private static List<string>? PromptForMultiple(string initialMessage, string subsequentPrompt) { /* ... same ... */ Console.WriteLine(initialMessage + Program.GetLocalizedString("PromptMultipleEndWithEmpty")); var items = new List<string>(); while(true) { Console.Write($"{subsequentPrompt}: "); var item = Console.ReadLine()?.Trim(); if (string.IsNullOrWhiteSpace(item)) break; items.Add(item); } return items.Any() ? items : null; } 

    private static async Task HandlePrepareInputLogic( 
        string? taskId, string? taskDesc, string[]? resources, string[]? newResources, string? continueTask, 
        string? taskType, int? storyPoints, string? priority, string? sprint, string? epicLink, DateTime? dueDate, string[]? labels, string? assignee, string? branch, string? humanNotes, 
        InvocationContext? cliContext = null ) 
    { 
        // ... (Logic is the same as v1.7, ensuring "Resource" terminology is used where "File" was before)
        var config = AIFlowConfigService.LoadConfig(); if (config == null) return; var projectRoot = Directory.GetCurrentDirectory(); Matcher ignoreMatcher = IgnoreService.LoadIgnoreMatcher(projectRoot); AIFlowTask? taskToProcess; bool isNewTask = false; bool isContinuingSplitRequest = !string.IsNullOrEmpty(continueTask); if (isContinuingSplitRequest) { taskToProcess = config.Tasks.FirstOrDefault(t => t.TaskId == continueTask); if (taskToProcess == null) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorTaskNotFoundForContinue", continueTask!)); return; } if (taskToProcess.Status != TaskStatus.PendingHumanInputParts || taskToProcess.HumanRequestGroupId == null || taskToProcess.HumanRequestTotalParts == null || taskToProcess.HumanRequestPartsSent >= taskToProcess.HumanRequestTotalParts) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorInvalidTaskStateForContinue", continueTask!)); return; } Console.WriteLine(Program.GetLocalizedString("ContinuingSplitRequest", taskToProcess.TaskId, taskToProcess.HumanRequestPartsSent + 1, taskToProcess.HumanRequestTotalParts!)); } else { if (string.IsNullOrEmpty(taskId) && string.IsNullOrEmpty(taskDesc)) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorTaskDescOrIdRequired")); return; } taskToProcess = config.Tasks.FirstOrDefault(t => t.TaskId == taskId); if (taskToProcess == null) { isNewTask = true; if (string.IsNullOrEmpty(taskDesc)) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorTaskDescRequiredForNewTask")); return; } taskToProcess = new AIFlowTask { TaskId = taskId ?? $"task_{config.NextTaskId++}", Description = taskDesc!, Branch = branch ?? config.CurrentBranch, Status = TaskStatus.ToDo, CreatedAt = DateTime.UtcNow, Type = taskType, StoryPoints = storyPoints, Priority = priority, Sprint = sprint, EpicLink = epicLink, DueDate = dueDate, Labels = labels?.ToList() ?? new List<string>(), AssignedTo = assignee ?? "ai", HumanNotes = humanNotes }; config.Tasks.Add(taskToProcess); } else { if (!string.IsNullOrEmpty(taskDesc)) taskToProcess.Description = taskDesc; bool hasBranchOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.branchOption) ?? (cliContext == null && branch != null); if (hasBranchOpt) taskToProcess.Branch = branch ?? taskToProcess.Branch; bool hasTypeOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.typeOption) ?? (cliContext == null && taskType != null); if (hasTypeOpt) taskToProcess.Type = taskType; else if (isNewTask && !hasTypeOpt) taskToProcess.Type = null; bool hasSpOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.storyPointsOption) ?? (cliContext == null && storyPoints.HasValue); if (hasSpOpt) taskToProcess.StoryPoints = storyPoints; else if (isNewTask && !hasSpOpt) taskToProcess.StoryPoints = null; bool hasPrioOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.priorityOption) ?? (cliContext == null && priority != null); if (hasPrioOpt) taskToProcess.Priority = priority; else if (isNewTask && !hasPrioOpt) taskToProcess.Priority = null; bool hasSprintOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.sprintOption) ?? (cliContext == null && sprint != null); if (hasSprintOpt) taskToProcess.Sprint = sprint; else if (isNewTask && !hasSprintOpt) taskToProcess.Sprint = null; bool hasEpicOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.epicLinkOption) ?? (cliContext == null && epicLink != null); if (hasEpicOpt) taskToProcess.EpicLink = epicLink; else if (isNewTask && !hasEpicOpt) taskToProcess.EpicLink = null; bool hasDueOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.dueDateOption) ?? (cliContext == null && dueDate.HasValue); if (hasDueOpt) taskToProcess.DueDate = dueDate; else if (isNewTask && !hasDueOpt) taskToProcess.DueDate = null; bool hasLabelsOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.labelsOption) ?? (cliContext == null && labels != null); if (hasLabelsOpt) taskToProcess.Labels = labels?.ToList() ?? taskToProcess.Labels; else if (isNewTask && !hasLabelsOpt) taskToProcess.Labels = new List<string>(); bool hasAssigneeOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.assigneeOption) ?? (cliContext == null && assignee != null); if (hasAssigneeOpt) taskToProcess.AssignedTo = assignee ?? taskToProcess.AssignedTo; else if (isNewTask && !hasAssigneeOpt) taskToProcess.AssignedTo = "ai"; bool hasNotesOpt = cliContext?.ParseResult.HasOption(PrepareInputCommand.humanNotesOption) ?? (cliContext == null && humanNotes != null); if (hasNotesOpt) taskToProcess.HumanNotes = humanNotes; else if (isNewTask && !hasNotesOpt) taskToProcess.HumanNotes = null; } taskToProcess.RelatedResources.Clear(); } 
        taskToProcess.UpdatedAt = DateTime.UtcNow; 
        var humanRequestPayload = new HumanRequestPayload { TaskId = taskToProcess.TaskId, TaskDescription = taskToProcess.Description, HumanRequestGroupId = taskToProcess.HumanRequestGroupId, FilesToProcess = new List<HumanRequestFileToProcess>(), FileData = new List<HumanRequestFileData>()}; long currentPayloadSize = 0; var allResourcesForTask = new List<(string path, string action, string? hashAtRequestTime, string? content, string type)>();
        if (resources != null) { foreach (var resourcePathInput in resources) { var fullPath = FileService.GetFullPath(resourcePathInput); var projectRelPath = FileService.GetProjectRelativePath(fullPath); if (IgnoreService.IsFileIgnored(projectRelPath, ignoreMatcher)) { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(Program.GetLocalizedString("WarningResourceIgnored", projectRelPath, IgnoreService.IgnoreFileName)); Console.ResetColor(); continue; } if (!File.Exists(fullPath)) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorResourceNotFound", projectRelPath)); continue; } var hash = FileService.CalculateFileHash(fullPath); if (hash == null) continue; string? content = null; if(!isContinuingSplitRequest || taskToProcess.RelatedResources.Any(rr => rr.Path == projectRelPath && rr.ContentDetail != null && rr.SentInPart == null)) { content = await File.ReadAllTextAsync(fullPath); } allResourcesForTask.Add((projectRelPath, "update", hash, content, ResourceType.LocalFile)); } }
        if (newResources != null) { foreach (var resourcePathInput in newResources) { var projectRelPath = FileService.GetProjectRelativePath(FileService.GetFullPath(resourcePathInput)); if (IgnoreService.IsFileIgnored(projectRelPath, ignoreMatcher)) { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(Program.GetLocalizedString("WarningNewResourceIgnored", projectRelPath, IgnoreService.IgnoreFileName)); Console.ResetColor(); continue; } allResourcesForTask.Add((projectRelPath, "create", null, null, ResourceType.LocalFile));} }
        int currentPartNumber = isContinuingSplitRequest ? taskToProcess.HumanRequestPartsSent + 1 : 1; bool needsSplitting = false; long tempPayloadSizeEstimate = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(humanRequestPayload)).Length; if (!isContinuingSplitRequest) { taskToProcess.RelatedResources.Clear(); foreach (var (path, fileAction, fileHash, fileContent, resourceType) in allResourcesForTask) { var relatedResourceEntry = new AIFlowTaskRelatedResource { Path = path, Action = fileAction, HashAtRequestTime = fileHash, Type = resourceType }; taskToProcess.RelatedResources.Add(relatedResourceEntry); tempPayloadSizeEstimate += Encoding.UTF8.GetBytes(path).Length + (fileContent != null ? Encoding.UTF8.GetBytes(FileService.Base64Encode(fileContent)).Length : 0) + 100; } if (tempPayloadSizeEstimate > config.Config.MaxRequestPayloadSizeBytes) { needsSplitting = true; taskToProcess.HumanRequestGroupId ??= $"hrg_{config.NextHumanRequestGroupId++}"; taskToProcess.Status = TaskStatus.PendingHumanInputParts; Console.WriteLine(Program.GetLocalizedString("InfoRequestWillBeSplit", taskToProcess.HumanRequestGroupId)); } humanRequestPayload.HumanRequestGroupId = taskToProcess.HumanRequestGroupId; }
        humanRequestPayload.PartNumber = currentPartNumber; if (currentPartNumber == 1) { humanRequestPayload.TaskDescription = taskToProcess.Description; foreach (var relatedResource in taskToProcess.RelatedResources) { var resourceData = allResourcesForTask.FirstOrDefault(r => r.path == relatedResource.Path); var reqFile = new HumanRequestFileToProcess { Path = relatedResource.Path, Action = relatedResource.Action, Hash = relatedResource.HashAtRequestTime }; if (resourceData.content != null && relatedResource.Type == ResourceType.LocalFile) { string encodedContent = FileService.Base64Encode(resourceData.content); long resourceSizeEstimate = Encoding.UTF8.GetBytes(reqFile.Path).Length + Encoding.UTF8.GetBytes(encodedContent).Length + 100; if (currentPayloadSize + resourceSizeEstimate < config.Config.MaxRequestPayloadSizeBytes * 0.9) { reqFile.ContentBase64 = encodedContent; currentPayloadSize += resourceSizeEstimate; relatedResource.SentInPart = 1; } else { reqFile.ContentDetail = "provided_in_next_part"; needsSplitting = true; relatedResource.ContentDetail = reqFile.ContentDetail; } } else if (relatedResource.Type != ResourceType.LocalFile) { reqFile.ContentDetail = $"type:{relatedResource.Type}"; relatedResource.SentInPart = 1; } humanRequestPayload.FilesToProcess!.Add(reqFile); } } else { var resourcesToSendInThisPart = taskToProcess.RelatedResources.Where(rr => rr.SentInPart == null && rr.ContentDetail != null && rr.Type == ResourceType.LocalFile).ToList(); foreach (var relatedResource in resourcesToSendInThisPart) { var resourceData = allResourcesForTask.FirstOrDefault(r => r.path == relatedResource.Path); if (resourceData.content == null) continue; string encodedContent = FileService.Base64Encode(resourceData.content); long resourceSizeEstimate = Encoding.UTF8.GetBytes(relatedResource.Path).Length + Encoding.UTF8.GetBytes(encodedContent).Length + 50; if (currentPayloadSize + resourceSizeEstimate < config.Config.MaxRequestPayloadSizeBytes * 0.95) { humanRequestPayload.FileData!.Add(new HumanRequestFileData { Path = relatedResource.Path, ContentBase64 = encodedContent }); currentPayloadSize += resourceSizeEstimate; relatedResource.SentInPart = currentPartNumber; } else { break; } } }
        if (needsSplitting || taskToProcess.HumanRequestGroupId != null) { taskToProcess.HumanRequestGroupId ??= $"hrg_{config.NextHumanRequestGroupId++}"; humanRequestPayload.HumanRequestGroupId = taskToProcess.HumanRequestGroupId; bool moreFilesToSend = taskToProcess.RelatedResources.Any(rr => rr.SentInPart == null && (rr.ContentDetail != null || (rr.Type == ResourceType.LocalFile && allResourcesForTask.FirstOrDefault(f=>f.path == rr.Path).content != null))); if (currentPartNumber == 1 && !moreFilesToSend && (humanRequestPayload.FileData == null || humanRequestPayload.FileData.Count == 0) ) { humanRequestPayload.TotalParts = 1; taskToProcess.HumanRequestTotalParts = 1; taskToProcess.Status = TaskStatus.PendingAiProcessing; } else if (moreFilesToSend) { humanRequestPayload.TotalParts = currentPartNumber + 1; taskToProcess.HumanRequestTotalParts = currentPartNumber + 1; taskToProcess.Status = TaskStatus.PendingHumanInputParts; } else { humanRequestPayload.TotalParts = currentPartNumber; taskToProcess.HumanRequestTotalParts = currentPartNumber; taskToProcess.Status = TaskStatus.PendingAiProcessing; } } else { humanRequestPayload.TotalParts = 1; taskToProcess.Status = TaskStatus.PendingAiProcessing; }
        taskToProcess.HumanRequestPartsSent = currentPartNumber; foreach (var relatedResource in taskToProcess.RelatedResources.Where(rr=>rr.SentInPart == currentPartNumber || (currentPartNumber == 1 && rr.SentInPart == null && rr.ContentDetail == null))) { var trackedResource = config.Resources.FirstOrDefault(r => r.Path == relatedResource.Path); if (trackedResource == null) { trackedResource = new AIFlowResource { Path = relatedResource.Path, Type = relatedResource.Type }; config.Resources.Add(trackedResource); } if (relatedResource.Action == "update" && relatedResource.HashAtRequestTime != null && relatedResource.Type == ResourceType.LocalFile) { trackedResource.LastSentToAiHash = relatedResource.HashAtRequestTime; } trackedResource.Status = ResourceStatus.AwaitingAiChanges; } 
        int estimatedTokens = EstimateTokens(humanRequestPayload); if (estimatedTokens > config.Config.ApproxMaxAiContextTokens) { Console.ForegroundColor = ConsoleColor.DarkYellow; Console.WriteLine(Program.GetLocalizedString("WarningTokenEstimateExceedsLimit", estimatedTokens, config.Config.ApproxMaxAiContextTokens, taskToProcess.TaskId, humanRequestPayload.PartNumber)); Console.ResetColor(); } else { Console.WriteLine(Program.GetLocalizedString("InfoTokenEstimate", estimatedTokens, humanRequestPayload.PartNumber)); }
        AIFlowConfigService.SaveConfig(config); 
        var finalPayload = new HumanRequestPart { HumanRequest = humanRequestPayload }; var jsonOutput = JsonSerializer.Serialize(finalPayload, new JsonSerializerOptions { WriteIndented = true, DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull }); Console.WriteLine(Program.GetLocalizedString("RequestPackageReady")); Console.WriteLine("--------------------------------------------------"); Console.WriteLine(jsonOutput); Console.WriteLine("--------------------------------------------------"); if (taskToProcess.Status == TaskStatus.PendingHumanInputParts && taskToProcess.HumanRequestTotalParts > taskToProcess.HumanRequestPartsSent) { Console.WriteLine(Program.GetLocalizedString("InstructionForNextPart", taskToProcess.TaskId)); } else if (taskToProcess.Status == TaskStatus.PendingAiProcessing) { Console.WriteLine(Program.GetLocalizedString("AllPartsSentAwaitingAI", taskToProcess.TaskId)); } 
    } 
    
    private static int EstimateTokens(HumanRequestPayload payload) { /* ... same as before ... */ const int charsPerToken = 4; int totalChars = 0; if (!string.IsNullOrEmpty(payload.TaskDescription)) { totalChars += payload.TaskDescription.Length; } if (payload.FilesToProcess != null) { foreach (var fileToProcess in payload.FilesToProcess) { if (!string.IsNullOrEmpty(fileToProcess.ContentBase64)) { try { string decodedContent = FileService.Base64Decode(fileToProcess.ContentBase64); totalChars += decodedContent.Length; } catch {} } } } if (payload.FileData != null) { foreach (var fileData in payload.FileData) { if (!string.IsNullOrEmpty(fileData.ContentBase64)) { try { string decodedContent = FileService.Base64Decode(fileData.ContentBase64); totalChars += decodedContent.Length; } catch {} } } } totalChars += 500; return totalChars / charsPerToken; } 
    private static async Task HandlePrepareInput(InvocationContext context, bool isInteractiveContext = true) { /* ... same as before ... */ await HandlePrepareInputLogic( context.ParseResult.GetValueForOption(taskIdOption), context.ParseResult.GetValueForOption(taskDescOption), context.ParseResult.GetValueForOption(resourcesOption), context.ParseResult.GetValueForOption(newResourcesOption), context.ParseResult.GetValueForOption(continueTaskOption), context.ParseResult.GetValueForOption(typeOption), context.ParseResult.GetValueForOption(storyPointsOption), context.ParseResult.GetValueForOption(priorityOption), context.ParseResult.GetValueForOption(sprintOption), context.ParseResult.GetValueForOption(epicLinkOption), context.ParseResult.GetValueForOption(dueDateOption), context.ParseResult.GetValueForOption(labelsOption), context.ParseResult.GetValueForOption(assigneeOption), context.ParseResult.GetValueForOption(branchOption), context.ParseResult.GetValueForOption(humanNotesOption), context ); } 
} 
}// --- END CHUNK: Commands/PrepareInputCommand.cs ---// --- START CHUNK: Commands/IntegrateOutputCommand.cs ---namespace AIFlow.Cli.Commands { /* ... IntegrateOutput code remains the same as SV003 version but uses "Resource" ... */ using System.CommandLine; using System.CommandLine.Invocation; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using AIFlow.Cli.Services.Payloads; using System.Text.Json; using System.Text; using System.IO; using System.Collections.Generic; using System.Linq; using System; public static class IntegrateOutputCommand { static Argument aiJsonPayloadArgument = new Argument("ai-json-payload", Program.GetLocalizedString("IntegrateOutputPayloadArgumentDescription")); static Option dryRunOption = new Option(aliases: new[] { "--dry-run", "-dr" }, description: Program.GetLocalizedString("DryRunOptionDescription")); public static Command Create() { var command = new Command("integrate-output", Program.GetLocalizedString("IntegrateOutputCommandDescription")); command.AddArgument(aiJsonPayloadArgument); command.AddOption(dryRunOption); command.SetHandler((InvocationContext context) => { var aiJsonPayload = context.ParseResult.GetValueForArgument(aiJsonPayloadArgument); var isDryRun = context.ParseResult.GetValueForOption(dryRunOption); HandleIntegrateOutput(aiJsonPayload, isDryRun); }); return command; }private static void HandleIntegrateOutput(string aiJsonPayload, bool isDryRun) { if (isDryRun) { Console.ForegroundColor = ConsoleColor.Cyan; Console.WriteLine(Program.GetLocalizedString("DryRunModeActive")); Console.ResetColor(); } var config = AIFlowConfigService.LoadConfig(); if (config == null) return; AIFlowFile configForSimulation = isDryRun ? JsonSerializer.Deserialize(JsonSerializer.Serialize(config))! : config; AiPreliminaryResponse? prelimResponse = null; AiOutputPackage? mainOutputPackage = null; AiBatchResponse? batchResponse = null; bool changesWouldBeAppliedOrMergeFileCreated = false; bool successfullyParsed = false; try { var prelimWrapper = JsonSerializer.Deserialize(aiJsonPayload, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); if (prelimWrapper?.AiPreliminaryResponse?.RetrievalGuid != null) { prelimResponse = prelimWrapper.AiPreliminaryResponse; successfullyParsed = true; } } catch {} if (!successfullyParsed) { try { var batchWrapper = JsonSerializer.Deserialize(aiJsonPayload, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); if(batchWrapper?.AiBatchResponse?.RetrievalGuid != null && batchWrapper.AiBatchResponse.Payload != null) { batchResponse = batchWrapper.AiBatchResponse; mainOutputPackage = batchResponse.Payload; mainOutputPackage.RetrievalGuid = batchResponse.RetrievalGuid; mainOutputPackage.BatchNumber = batchResponse.BatchNumber; mainOutputPackage.TotalBatches = batchResponse.TotalBatches; mainOutputPackage.IsLastBatch = batchResponse.IsLastBatch; successfullyParsed = true; }} catch {}} if (!successfullyParsed) { try { var directWrapper = JsonSerializer.Deserialize(aiJsonPayload, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); if(directWrapper?.AiOutputPackage?.AiChangesetId != null) { mainOutputPackage = directWrapper.AiOutputPackage; successfullyParsed = true; } else { mainOutputPackage = JsonSerializer.Deserialize(aiJsonPayload, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); if(mainOutputPackage?.AiChangesetId != null) successfullyParsed = true; }} catch {} } if (!successfullyParsed) { try { using JsonDocument doc = JsonDocument.Parse(aiJsonPayload); JsonElement root = doc.RootElement; bool hasAiChangesetId = root.TryGetProperty("aiChangesetId", out _) || (root.TryGetProperty("aiOutputPackage", out var pkg) && pkg.TryGetProperty("aiChangesetId", out _)) || (root.TryGetProperty("aiBatchResponse", out var batch) && batch.TryGetProperty("aiChangesetId", out _)) || (root.TryGetProperty("aiPreliminaryResponse", out var prelim) && prelim.TryGetProperty("aiChangesetId", out _)); bool hasFileChanges = root.TryGetProperty("fileChanges", out JsonElement fc) && fc.ValueKind == JsonValueKind.Array || (root.TryGetProperty("aiOutputPackage", out pkg) && pkg.TryGetProperty("fileChanges", out fc) && fc.ValueKind == JsonValueKind.Array) || (root.TryGetProperty("aiBatchResponse", out batch) && batch.TryGetProperty("payload", out var batchPayload) && batchPayload.TryGetProperty("fileChanges", out fc) && fc.ValueKind == JsonValueKind.Array); if (hasAiChangesetId || hasFileChanges) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorAIJsonValidButUnrecognizedStructure")); } else { Console.Error.WriteLine(Program.GetLocalizedString("ErrorAIJsonValidButNotAIFlowFormat")); } } catch (JsonException jsonEx) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorAIJsonMalformed", jsonEx.Message)); } return; }if (prelimResponse != null) { Console.WriteLine(Program.GetLocalizedString("AIOutputIsBatched", prelimResponse.NumberOfBatches, prelimResponse.RetrievalGuid)); if (!isDryRun) { configForSimulation.ActiveAiRetrievalSession = new ActiveRetrievalSession { RetrievalGuid = prelimResponse.RetrievalGuid, AiChangesetId = prelimResponse.AiChangesetId, TotalBatches = prelimResponse.NumberOfBatches, ReceivedBatchesCount = 0, ReceivedBatchPayloads = new List() }; AIFlowConfigService.SaveConfig(configForSimulation); } else { Console.WriteLine(Program.GetLocalizedString("DryRunWouldUpdateActiveSession")); } Console.WriteLine(Program.GetLocalizedString("RunFetchOutputCommand", prelimResponse.RetrievalGuid, 1)); return; } if (mainOutputPackage == null) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorInvalidAIJsonStructure")); return; } AIFlowTask? task = null; if (mainOutputPackage.TaskUpdates?.TaskId != null) { task = configForSimulation.Tasks.FirstOrDefault(t => t.TaskId == mainOutputPackage.TaskUpdates.TaskId); } else if (!string.IsNullOrEmpty(mainOutputPackage.HumanRequestId)) { task = configForSimulation.Tasks.FirstOrDefault(t => t.TaskId == mainOutputPackage.HumanRequestId || t.HumanRequestGroupId == mainOutputPackage.HumanRequestId); } if (task == null && configForSimulation.ActiveAiRetrievalSession?.RetrievalGuid != mainOutputPackage.RetrievalGuid) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorTaskNotFoundForAIResponse", mainOutputPackage.TaskUpdates?.TaskId ?? mainOutputPackage.HumanRequestId ?? "N/A")); return; } if (mainOutputPackage.RetrievalGuid != null && configForSimulation.ActiveAiRetrievalSession?.RetrievalGuid == mainOutputPackage.RetrievalGuid) { var session = configForSimulation.ActiveAiRetrievalSession; if(!isDryRun) session.ReceivedBatchPayloads.Add(aiJsonPayload); session.ReceivedBatchesCount++; Console.WriteLine(Program.GetLocalizedString("BatchReceived", session.ReceivedBatchesCount, session.TotalBatches, session.RetrievalGuid)); if (session.ReceivedBatchesCount < session.TotalBatches) { if(!isDryRun) AIFlowConfigService.SaveConfig(configForSimulation); else Console.WriteLine(Program.GetLocalizedString("DryRunWouldSaveConfigForBatch")); Console.WriteLine(Program.GetLocalizedString("RunFetchOutputCommand", session.RetrievalGuid, session.ReceivedBatchesCount + 1)); return; } else { Console.WriteLine(Program.GetLocalizedString("AllBatchesReceivedProcessing", session.RetrievalGuid)); var consolidatedFileChanges = new List(); AiTaskUpdate? finalTaskUpdate = null; var payloadsToProcess = isDryRun ? new List{ aiJsonPayload } : session.ReceivedBatchPayloads; foreach(var batchJson in payloadsToProcess) { var storedBatchWrapper = JsonSerializer.Deserialize(batchJson, new JsonSerializerOptions{PropertyNameCaseInsensitive = true}); var storedBatchPayload = storedBatchWrapper?.AiBatchResponse?.Payload; if (storedBatchPayload?.FileChanges != null) consolidatedFileChanges.AddRange(storedBatchPayload.FileChanges); if (storedBatchPayload?.TaskUpdates != null) finalTaskUpdate = storedBatchPayload.TaskUpdates; } mainOutputPackage.FileChanges = consolidatedFileChanges.DistinctBy(fc => fc.Path).ToList(); mainOutputPackage.TaskUpdates = finalTaskUpdate ?? mainOutputPackage.TaskUpdates; if(!isDryRun) configForSimulation.ActiveAiRetrievalSession = null; else Console.WriteLine(Program.GetLocalizedString("DryRunWouldClearActiveSession")); } }string? backupId = null; if (!isDryRun && mainOutputPackage.FileChanges != null && mainOutputPackage.FileChanges.Any()) { var resourcesToBackup = new List(); foreach (var change in mainOutputPackage.FileChanges) { if (change.Action.Equals("update", StringComparison.OrdinalIgnoreCase) || change.Action.Equals("delete", StringComparison.OrdinalIgnoreCase)) { var fullPath = FileService.GetFullPath(change.Path); if (File.Exists(fullPath)) { resourcesToBackup.Add(change.Path); } } } if (resourcesToBackup.Any() || true) { backupId = BackupService.CreateBackup(config, resourcesToBackup, task?.TaskId, mainOutputPackage.AiChangesetId); if (string.IsNullOrEmpty(backupId)) { Console.Error.WriteLine(Program.GetLocalizedString("BackupFailedProceedWithCaution")); Console.Write(Program.GetLocalizedString("PromptProceedWithoutBackup")); if(Console.ReadLine()?.Trim().ToLowerInvariant() != "y") { Console.WriteLine(Program.GetLocalizedString("IntegrationAborted")); return; } } } } else if (isDryRun && mainOutputPackage.FileChanges != null && mainOutputPackage.FileChanges.Any()) { Console.WriteLine(Program.GetLocalizedString("DryRunWouldCreateBackup")); }bool anyResourceSkippedOrMerged = false; if (mainOutputPackage.FileChanges != null) { foreach (var change in mainOutputPackage.FileChanges) { var fullPath = FileService.GetFullPath(change.Path); var trackedResource = configForSimulation.Resources.FirstOrDefault(r => r.Path == change.Path); if (change.Action.Equals("delete", StringComparison.OrdinalIgnoreCase)) { if (isDryRun) { Console.WriteLine(Program.GetLocalizedString("DryRunWouldDeleteResource", change.Path)); } else { if (File.Exists(fullPath)) { File.Delete(fullPath); Console.WriteLine(Program.GetLocalizedString("ResourceDeleted", change.Path));} if (trackedResource != null) configForSimulation.Resources.Remove(trackedResource); } changesWouldBeAppliedOrMergeFileCreated = true; continue; } if (string.IsNullOrEmpty(change.ContentBase64)) { Console.WriteLine(Program.GetLocalizedString("SkippingResourceNoContent", change.Path)); continue; } string aiResourceContent = FileService.Base64Decode(change.ContentBase64); if (trackedResource == null) { trackedResource = new AIFlowResource { Path = change.Path, Type = ResourceType.LocalFile }; if(!isDryRun) configForSimulation.Resources.Add(trackedResource); else Console.WriteLine(Program.GetLocalizedString("DryRunWouldAddTrackedResource", change.Path));} bool applyAIChangesDirectly = true; if (change.Action.Equals("update", StringComparison.OrdinalIgnoreCase) && trackedResource.Type == ResourceType.LocalFile) { string? currentLocalDiskContent = null; string? currentLocalDiskHash = null; if (File.Exists(fullPath)) { try { currentLocalDiskContent = File.ReadAllText(fullPath); } catch {} currentLocalDiskHash = FileService.CalculateFileHash(fullPath); } if (trackedResource.LastSentToAiHash != null && currentLocalDiskHash != null && currentLocalDiskHash != trackedResource.LastSentToAiHash) { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(Program.GetLocalizedString("ConflictResourceChangedLocallyDetailed", change.Path, currentLocalDiskHash.Substring(0, Math.Min(currentLocalDiskHash.Length, 7)), trackedResource.LastSentToAiHash.Substring(0, Math.Min(trackedResource.LastSentToAiHash.Length, 7)), change.BasedOnHash?.Substring(0, Math.Min(change.BasedOnHash.Length, 7)) ?? "N/A" )); Console.ResetColor(); if (isDryRun) { Console.WriteLine(Program.GetLocalizedString("DryRunWouldPromptConflict", change.Path)); Console.WriteLine(Program.GetLocalizedString("DryRunSimulatingOverwrite", change.Path)); } else { string? choice = null; while (choice != "o" && choice != "s" && choice != "m") { Console.Write(Program.GetLocalizedString("PromptOverwriteSkipMerge", change.Path)); choice = Console.ReadLine()?.Trim().ToLowerInvariant(); } if (choice == "s") { applyAIChangesDirectly = false; trackedResource.Status = ResourceStatus.NeedsManualMerge; Console.WriteLine(Program.GetLocalizedString("SkippingAIChangesForResource", change.Path, trackedResource.Status)); anyResourceSkippedOrMerged = true; } else if (choice == "m") { applyAIChangesDirectly = false; anyResourceSkippedOrMerged = true; try { var conflictContent = new StringBuilder(); conflictContent.AppendLine("<<<<<<<CurrentLocalChanges");conflictContent.AppendLine(currentLocalDiskContent??string.Empty);conflictContent.AppendLine("======="); conflictContent.AppendLine(aiResourceContent); conflictContent.AppendLine($">>>>>>> AI's Change (Task: {task?.TaskId ?? "N/A"} / AIFlow)"); Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!); File.WriteAllText(fullPath, conflictContent.ToString()); trackedResource.Status = ResourceStatus.NeedsManualMerge; trackedResource.ConflictResolutionFile = null; Console.WriteLine(Program.GetLocalizedString("MergeMarkersWrittenToOriginalFile", change.Path)); Console.WriteLine(Program.GetLocalizedString("ResolveOriginalFileInstruction", change.Path)); } catch (Exception ex) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorWritingMergeMarkers", change.Path, ex.Message)); trackedResource.Status = ResourceStatus.NeedsManualMerge; } } } } else if (trackedResource.LastSentToAiHash != null && change.BasedOnHash != null && trackedResource.LastSentToAiHash != change.BasedOnHash) { Console.ForegroundColor = ConsoleColor.DarkYellow; Console.WriteLine(Program.GetLocalizedString("WarningAIUsedStaleVersion", change.Path, change.BasedOnHash, trackedResource.LastSentToAiHash)); Console.ResetColor(); } } if (applyAIChangesDirectly) { if(isDryRun) { Console.WriteLine(Program.GetLocalizedString(change.Action.Equals("create", StringComparison.OrdinalIgnoreCase) ? "DryRunWouldCreateResource" : "DryRunWouldUpdateResource", change.Path)); if (trackedResource != null) { trackedResource.Status = ResourceStatus.AiModified; } } else { if (trackedResource.Type == ResourceType.LocalFile) { try { Directory.CreateDirectory(Path.GetDirectoryName(fullPath)!); File.WriteAllText(fullPath, aiResourceContent); Console.WriteLine(Program.GetLocalizedString(change.Action.Equals("create", StringComparison.OrdinalIgnoreCase) ? "ResourceCreated" : "ResourceUpdated", change.Path)); trackedResource.LocalHash = FileService.CalculateFileHash(fullPath) ?? string.Empty; trackedResource.Status = ResourceStatus.AiModified; trackedResource.LastSentToAiHash = null; trackedResource.ConflictResolutionFile = null; } catch (Exception ex) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorWritingFile", change.Path, ex.Message)); } } else { Console.WriteLine(Program.GetLocalizedString("ResourceReferenceUpdated", change.Path, trackedResource.Type)); trackedResource.Status = ResourceStatus.AiModified; } } changesWouldBeAppliedOrMergeFileCreated = true; } } }if (task != null && mainOutputPackage.TaskUpdates != null) { string originalTaskStatus = task.Status; string newTaskStatus = mainOutputPackage.TaskUpdates.NewStatus ?? originalTaskStatus; string? newAiNotes = mainOutputPackage.TaskUpdates.AiNotes ?? task.AiNotes; DateTime newUpdatedAt = mainOutputPackage.TaskUpdates.UpdatedAt ?? DateTime.UtcNow; if (anyResourceSkippedOrMerged && (newTaskStatus == TaskStatus.Completed || newTaskStatus == TaskStatus.Done)) { newTaskStatus = TaskStatus.PendingHumanReview; if(isDryRun) Console.WriteLine(Program.GetLocalizedString("DryRunTaskStatusAdjustedForSkippedFiles", task.TaskId, newTaskStatus)); else Console.WriteLine(Program.GetLocalizedString("TaskStatusAdjustedForSkippedFiles", task.TaskId, newTaskStatus)); } if(isDryRun) { Console.WriteLine(Program.GetLocalizedString("DryRunWouldUpdateTask", task.TaskId, newTaskStatus, newAiNotes ?? "N/A")); } else { task.Status = newTaskStatus; task.AiNotes = newAiNotes; task.UpdatedAt = newUpdatedAt; Console.WriteLine(Program.GetLocalizedString("TaskUpdated", task.TaskId, task.Status)); } changesWouldBeAppliedOrMergeFileCreated = true; }if (!isDryRun) { AIFlowConfigService.SaveConfig(configForSimulation); } else { Console.WriteLine(Program.GetLocalizedString("DryRunWouldSaveConfig")); } if(changesWouldBeAppliedOrMergeFileCreated || mainOutputPackage.TaskUpdates != null) { Console.WriteLine(isDryRun ? Program.GetLocalizedString("DryRunSummaryChanges") : Program.GetLocalizedString("AIOutputIntegrated")); } else { Console.WriteLine(isDryRun ? Program.GetLocalizedString("DryRunSummaryNoChanges") : Program.GetLocalizedString("AIOutputProcessedNoChangesApplied")); } if (isDryRun) { Console.ForegroundColor = ConsoleColor.Cyan; Console.WriteLine(Program.GetLocalizedString("DryRunModeEnded")); Console.ResetColor(); } } } }// --- END CHUNK: Commands/IntegrateOutputCommand.cs ---// --- START CHUNK: Commands/FetchOutputCommand.cs ---namespace AIFlow.Cli.Commands { /* ... FetchOutput code remains the same ... */ using System.CommandLine; using AIFlow.Cli.Services; using System.Linq; using AIFlow.Cli.Models; public static class FetchOutputCommand { public static Command Create() { var command = new Command("fetch-output", Program.GetLocalizedString("FetchOutputCommandDescription")) { new Option(aliases: new[] { "--retrieval-id", "-rid" }, description: Program.GetLocalizedString("FetchOutputRetrievalIdOptionDescription")) { IsRequired = true }, new Option(aliases: new[] { "--batch", "-b" }, description: Program.GetLocalizedString("FetchOutputBatchOptionDescription")) { IsRequired = true } }; command.SetHandler((string retrievalId, int batchNumber) => { var config = AIFlowConfigService.LoadConfig(); if (config?.ActiveAiRetrievalSession?.RetrievalGuid != retrievalId) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorNoActiveRetrievalSession", retrievalId));} Console.WriteLine(Program.GetLocalizedString("FetchOutputInstructionTitle")); Console.WriteLine("--------------------------------------------------"); Console.WriteLine(Program.GetLocalizedString("FetchOutputAIMessage", batchNumber, retrievalId)); Console.WriteLine("--------------------------------------------------"); Console.WriteLine(Program.GetLocalizedString("FetchOutputNextStep")); }, command.Options.OfType<Option>().First(), command.Options.OfType<Option>().First()); return command; } } }// --- END CHUNK: Commands/FetchOutputCommand.cs ---// --- START CHUNK: Commands/StatusCommand.cs ---namespace AIFlow.Cli.Commands { /* ... Status code remains the same as v1.7 ... */ using System.CommandLine; using System.CommandLine.Invocation; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.Text; using System.Linq; using System.Collections.Generic; using System; using System.IO; public static class StatusCommand { static Option detailedOption = new Option("--detailed", () => false, Program.GetLocalizedString("StatusDetailedOptionDescription")); static Option<string?> branchOption = new Option<string?>("--branch", () => null, Program.GetLocalizedString("TaskListBranchOptionDescription")); static Option includeArchivedOption = new Option("--include-archived", () => false, Program.GetLocalizedString("StatusIncludeArchivedOptionDescription")); public static Command Create() { var command = new Command("status", Program.GetLocalizedString("StatusCommandDescription")); command.AddOption(detailedOption); command.AddOption(branchOption); command.AddOption(includeArchivedOption); command.SetHandler((InvocationContext context) => { var detailed = context.ParseResult.GetValueForOption(detailedOption); var filterBranch = context.ParseResult.GetValueForOption(branchOption); var includeArchived = context.ParseResult.GetValueForOption(includeArchivedOption); HandleStatus(detailed, filterBranch, includeArchived); }); return command; } private static void HandleStatus(bool detailed, string? filterBranch, bool includeArchived) { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; Console.WriteLine(Program.GetLocalizedString("StatusProjectName", config.ProjectName)); Console.WriteLine(Program.GetLocalizedString("StatusCurrentBranch", config.CurrentBranch)); Console.WriteLine(); Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(Program.GetLocalizedString("StatusUnmanagedLocalChangesHeader")); Console.ResetColor(); var unmanagedResources = new List(); foreach (var resource in config.Resources.OrderBy(r => r.Path)) { if (resource.Type == ResourceType.LocalFile && !(resource.Status == ResourceStatus.AiModified || resource.Status == ResourceStatus.NeedsManualMerge || resource.Status == ResourceStatus.Merged || resource.Status == ResourceStatus.AwaitingAiChanges)) { string currentDiskHash = FileService.CalculateFileHash(FileService.GetFullPath(resource.Path)) ?? "Missing"; if (currentDiskHash != "Missing" && !string.IsNullOrEmpty(resource.LocalHash) && resource.LocalHash != currentDiskHash) { unmanagedResources.Add(resource); Console.WriteLine(Program.GetLocalizedString("StatusResourceLocallyModified", resource.Path, currentDiskHash.Substring(0, Math.Min(currentDiskHash.Length,7)), resource.LocalHash.Substring(0, Math.Min(resource.LocalHash.Length,7)))); } } } if (!unmanagedResources.Any()) Console.WriteLine(Program.GetLocalizedString("StatusNoUnmanagedChanges")); Console.WriteLine(); Console.WriteLine(Program.GetLocalizedString("StatusTrackedResourcesHeader")); if (!config.Resources.Any()) Console.WriteLine(Program.GetLocalizedString("StatusNoTrackedResources")); foreach (var resource in config.Resources.OrderBy(r=>r.Path)) { string currentDiskHash = resource.Type == ResourceType.LocalFile ? (FileService.CalculateFileHash(FileService.GetFullPath(resource.Path)) ?? "Missing") : "N/A"; string statusIndicator = resource.Status; string conflictNote = resource.Status == ResourceStatus.NeedsManualMerge && resource.Type == ResourceType.LocalFile ? " (Contains conflict markers)" : ""; Console.WriteLine("  {resource.Path,-40} (Type: {resource.Type, -10} Status: {statusIndicator,-20} DiskHash: {(currentDiskHash == "N/A" ? "N/A" : currentDiskHash.Substring(0, Math.Min(currentDiskHash.Length,7)))}...){conflictNote}"); } Console.WriteLine(); Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine(Program.GetLocalizedString("StatusOverdueTasksHeader")); Console.ResetColor(); var overdueTasksQuery = config.Tasks.Where(t => t.DueDate.HasValue && t.DueDate.Value.Date < DateTime.UtcNow.Date && t.Status != TaskStatus.Done && t.Status != TaskStatus.Completed); if (!includeArchived) overdueTasksQuery = overdueTasksQuery.Where(t => t.Status != TaskStatus.Archived); var overdueTasks = overdueTasksQuery.OrderBy(t => t.DueDate).ToList(); if (!overdueTasks.Any()) Console.WriteLine(Program.GetLocalizedString("StatusNoOverdueTasks")); foreach(var task in overdueTasks) { Console.WriteLine(Program.GetLocalizedString("StatusOverdueTaskEntry", task.TaskId, task.DueDate.Value.ToShortDateString(), task.Branch, task.Description.Substring(0, Math.Min(task.Description.Length, 40)) )); } Console.WriteLine(); Console.WriteLine(Program.GetLocalizedString("StatusTasksHeader")); var tasksToDisplay = config.Tasks.AsEnumerable(); if (!includeArchived) { tasksToDisplay = tasksToDisplay.Where(t => t.Status != TaskStatus.Archived); } if (!string.IsNullOrWhiteSpace(filterBranch)) { tasksToDisplay = tasksToDisplay.Where(t => t.Branch.Equals(filterBranch, StringComparison.OrdinalIgnoreCase)); } var tasksList = tasksToDisplay.ToList(); if (!tasksList.Any()) Console.WriteLine(includeArchived ? Program.GetLocalizedString("StatusNoTasksIncludingArchived") : Program.GetLocalizedString("StatusNoActiveTasks")); foreach (var task in tasksList.OrderByDescending(t => t.UpdatedAt)) { var sb = new StringBuilder(); sb.Append("  Task ID: {task.TaskId,-10} Branch: {task.Branch,-15} Status: {task.Status,-15}"); if (!string.IsNullOrEmpty(task.Priority)) sb.Append("Prio:task.Priority,−8");if(!string.IsNullOrEmpty(task.Type))sb.Append(" Type: {task.Type,-8}"); sb.Append(" Desc: {task.Description.Substring(0, Math.Min(task.Description.Length, 30))}..."); Console.WriteLine(sb.ToString()); if (detailed) { Console.Write("    Assigned: {task.AssignedTo}"); if (task.StoryPoints.HasValue) Console.Write(",SP:task.StoryPoints");if(!string.IsNullOrEmpty(task.Sprint))Console.Write(", Sprint: {task.Sprint}"); if (task.DueDate.HasValue) Console.Write(",Due:task.DueDate.Value.ToShortDateString()");Console.WriteLine();if(task.Labels.Any())Console.WriteLine("    Labels: {string.Join(", ", task.Labels)}"); if (!string.IsNullOrEmpty(task.EpicLink)) Console.WriteLine("EpicLink:task.EpicLink");if(task.RelatedResources.Any())Console.WriteLine("    Resources: {task.RelatedResources.Count}"); } } Console.WriteLine(); Console.WriteLine(Program.GetLocalizedString("StatusTaskSummaryHeader")); var statusSummary = config.Tasks .GroupBy(t => t.Status) .Select(g => new { Status = g.Key, Count = g.Count() }) .OrderBy(s => s.Status).ToList(); if (!statusSummary.Any()) Console.WriteLine(Program.GetLocalizedString("StatusNoTasksForSummary")); foreach(var summary in statusSummary) { Console.WriteLine(Program.GetLocalizedString("StatusTaskSummaryEntry", summary.Status, summary.Count)); } Console.WriteLine(); if(config.ActiveAiRetrievalSession != null) { Console.WriteLine(Program.GetLocalizedString("StatusActiveRetrieval", config.ActiveAiRetrievalSession.RetrievalGuid, config.ActiveAiRetrievalSession.ReceivedBatchesCount, config.ActiveAiRetrievalSession.TotalBatches)); } } } }// --- END CHUNK: Commands/StatusCommand.cs ---// --- START CHUNK: Commands/BranchCommand.cs ---namespace AIFlow.Cli.Commands { /* ... Branch code remains the same ... / using System.CommandLine; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.Collections.Generic; using System.Linq; using System; public static class BranchCommand { public static Command Create() { var command = new Command("branch", Program.GetLocalizedString("BranchCommandDescription")) { new Argument<string?>("branch-name", () => null, Program.GetLocalizedString("BranchNameArgumentDescription")), new Option(aliases: new[] { "--delete", "-d" }, description: "Conceptually delete a branch (not implemented, branches are dynamic based on tasks).") }; var branchNameArgument = command.Arguments.OfType<Argument<string?>>().First(); var deleteOption = command.Options.OfType<Option>().First(o => o.HasAlias("-d")); command.SetHandler((string? branchName, bool delete) => { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; if (delete) { Console.WriteLine(Program.GetLocalizedString("BranchDeleteNotImplemented")); return; } if (string.IsNullOrEmpty(branchName)) { Console.WriteLine(Program.GetLocalizedString("BranchListingBranches")); var branches = new HashSet { "main", "develop" }; foreach(var taskBranch in config.Tasks.Select(t => t.Branch).Distinct()) { branches.Add(taskBranch); } foreach (var b in branches.OrderBy(b => b)) { Console.WriteLine($"  {(b == config.CurrentBranch ? "" : " ")} {b}"); } } else { if (!branchName.StartsWith("feature/") && !branchName.StartsWith("bugfix/") && !branchName.StartsWith("release/") && !branchName.StartsWith("hotfix/") && branchName != "main" && branchName != "develop") { Console.WriteLine(Program.GetLocalizedString("BranchGitflowSuggestion", branchName)); } Console.WriteLine(Program.GetLocalizedString("BranchCreationNote", branchName)); Console.WriteLine(Program.GetLocalizedString("UseCheckoutToSwitch", branchName)); } }, branchNameArgument, deleteOption); return command; } } }// --- END CHUNK: Commands/BranchCommand.cs ---// --- START CHUNK: Commands/CheckoutCommand.cs ---namespace AIFlow.Cli.Commands { /* ... Checkout code remains the same ... */ using System.CommandLine; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.Linq; public static class CheckoutCommand { public static Command Create() { var command = new Command("checkout", Program.GetLocalizedString("CheckoutCommandDescription")) { new Argument("branch-name", Program.GetLocalizedString("CheckoutBranchNameArgumentDescription")) }; var branchNameArgument = command.Arguments.OfType<Argument>().First(); command.SetHandler((string branchName) => { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; config.CurrentBranch = branchName; if (AIFlowConfigService.SaveConfig(config)) Console.WriteLine(Program.GetLocalizedString("CheckoutSuccess", branchName)); else Console.Error.WriteLine(Program.GetLocalizedString("CheckoutFailed", branchName)); }, branchNameArgument); return command; } } }// --- END CHUNK: Commands/CheckoutCommand.cs ---// --- START CHUNK: Commands/TaskCommand.cs ---namespace AIFlow.Cli.Commands { /* ... TaskCommand code remains the same as v1.7 ... */ using System.CommandLine; using System.CommandLine.Invocation; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.Linq; using System.Text; using System.Collections.Generic; using System; public static class TaskCommand { static Option<string?> updateDescOption = new Option<string?>("--desc", Program.GetLocalizedString("TaskUpdateDescOptionDescription")); static Option<string?> updateStatusOption = new Option<string?>("--status", Program.GetLocalizedString("TaskUpdateStatusOptionDescription")); static Option<string?> updateTypeOption = new Option<string?>("--type", Program.GetLocalizedString("TaskUpdateTypeOptionDescription_Optional")); static Option<int?> updateSpOption = new Option<int?>("--sp", Program.GetLocalizedString("TaskUpdateSpOptionDescription")); static Option<string?> updatePriorityOption = new Option<string?>("--priority", Program.GetLocalizedString("TaskUpdatePriorityOptionDescription_Optional")); static Option<string?> updateSprintOption = new Option<string?>("--sprint", Program.GetLocalizedString("TaskUpdateSprintOptionDescription")); static Option<string?> updateEpicLinkOption = new Option<string?>("--epic-link", Program.GetLocalizedString("TaskUpdateEpicLinkOptionDescription")); static Option<DateTime?> updateDueDateOption = new Option<DateTime?>("--due-date", Program.GetLocalizedString("TaskUpdateDueDateOptionDescription")); static Option<string[]?> updateLabelsOption = new Option<string[]?>("--labels", description: Program.GetLocalizedString("TaskUpdateLabelsOptionDescription")) { Arity = ArgumentArity.ZeroOrMore }; static Option<string?> updateAssigneeOption = new Option<string?>("--assignee", Program.GetLocalizedString("TaskUpdateAssigneeOptionDescription")); static Option<string?> updateBranchOption = new Option<string?>("--branch", Program.GetLocalizedString("TaskUpdateBranchOptionDescription")); static Option<string?> statusFilterOption = new Option<string?>("--status", description: Program.GetLocalizedString("TaskListStatusOptionDescription")); static Option<string?> branchFilterOptionList = new Option<string?>("--branch", description: Program.GetLocalizedString("TaskListBranchOptionDescription")); static Option<string?> assigneeFilterOption = new Option<string?>("--assignee", description: Program.GetLocalizedString("TaskListAssigneeOptionDescription")); static Option<string?> priorityFilterOption = new Option<string?>("--priority", description: Program.GetLocalizedString("TaskListPriorityOptionDescription")); static Option<string?> typeFilterOption = new Option<string?>("--type", description: Program.GetLocalizedString("TaskListTypeOptionDescription")); static Option<string[]?> labelsFilterOption = new Option<string[]?>("--label", description: Program.GetLocalizedString("TaskListLabelOptionDescription")) { Arity = ArgumentArity.ZeroOrMore }; static Option<string?> descContainsFilterOption = new Option<string?>("--desc-contains", description: Program.GetLocalizedString("TaskListDescContainsOptionDescription")); static Option<DateTime?> createdAfterOption = new Option<DateTime?>("--created-after", description: Program.GetLocalizedString("TaskListCreatedAfterOptionDescription")); static Option<DateTime?> createdBeforeOption = new Option<DateTime?>("--created-before", description: Program.GetLocalizedString("TaskListCreatedBeforeOptionDescription")); static Option<DateTime?> updatedAfterOption = new Option<DateTime?>("--updated-after", description: Program.GetLocalizedString("TaskListUpdatedAfterOptionDescription")); static Option<DateTime?> updatedBeforeOption = new Option<DateTime?>("--updated-before", description: Program.GetLocalizedString("TaskListUpdatedBeforeOptionDescription")); static Option<DateTime?> dueAfterOption = new Option<DateTime?>("--due-after", description: Program.GetLocalizedString("TaskListDueAfterOptionDescription")); static Option<DateTime?> dueBeforeOption = new Option<DateTime?>("--due-before", description: Program.GetLocalizedString("TaskListDueBeforeOptionDescription")); static Option includeArchivedOptionList = new Option("--include-archived", () => false, Program.GetLocalizedString("TaskListIncludeArchivedOptionDescription")); public static Command Create() { var taskCommand = new Command("task", Program.GetLocalizedString("TaskCommandDescription")); var listSubCommand = new Command("list", Program.GetLocalizedString("TaskListSubCommandDescription")); listSubCommand.AddOption(statusFilterOption); listSubCommand.AddOption(branchFilterOptionList); listSubCommand.AddOption(assigneeFilterOption); listSubCommand.AddOption(priorityFilterOption); listSubCommand.AddOption(typeFilterOption); listSubCommand.AddOption(labelsFilterOption); listSubCommand.AddOption(descContainsFilterOption); listSubCommand.AddOption(createdAfterOption); listSubCommand.AddOption(createdBeforeOption); listSubCommand.AddOption(updatedAfterOption); listSubCommand.AddOption(updatedBeforeOption); listSubCommand.AddOption(dueAfterOption); listSubCommand.AddOption(dueBeforeOption); listSubCommand.AddOption(includeArchivedOptionList); listSubCommand.SetHandler((InvocationContext context) => { ListTasks( context.ParseResult.GetValueForOption(statusFilterOption), context.ParseResult.GetValueForOption(branchFilterOptionList), context.ParseResult.GetValueForOption(assigneeFilterOption), context.ParseResult.GetValueForOption(priorityFilterOption), context.ParseResult.GetValueForOption(typeFilterOption), context.ParseResult.GetValueForOption(labelsFilterOption), context.ParseResult.GetValueForOption(descContainsFilterOption), context.ParseResult.GetValueForOption(createdAfterOption), context.ParseResult.GetValueForOption(createdBeforeOption), context.ParseResult.GetValueForOption(updatedAfterOption), context.ParseResult.GetValueForOption(updatedBeforeOption), context.ParseResult.GetValueForOption(dueAfterOption), context.ParseResult.GetValueForOption(dueBeforeOption), context.ParseResult.GetValueForOption(includeArchivedOptionList) ); }); taskCommand.AddCommand(listSubCommand); var viewSubCommand = new Command("view", Program.GetLocalizedString("TaskViewSubCommandDescription")); var taskIdArgumentView = new Argument("task-id", Program.GetLocalizedString("TaskViewIdArgumentDescription")); viewSubCommand.AddArgument(taskIdArgumentView); viewSubCommand.SetHandler((string taskId) => { ViewTask(taskId); }, taskIdArgumentView); taskCommand.AddCommand(viewSubCommand); var updateSubCommand = new Command("update", Program.GetLocalizedString("TaskUpdateSubCommandDescription")); var taskIdArgumentUpdate = new Argument("task-id", Program.GetLocalizedString("TaskUpdateIdArgumentDescription")); updateSubCommand.AddArgument(taskIdArgumentUpdate); updateSubCommand.AddOption(updateDescOption); updateSubCommand.AddOption(updateStatusOption); updateSubCommand.AddOption(updateTypeOption); updateSubCommand.AddOption(updateSpOption); updateSubCommand.AddOption(updatePriorityOption); updateSubCommand.AddOption(updateSprintOption); updateSubCommand.AddOption(updateEpicLinkOption); updateSubCommand.AddOption(updateDueDateOption); updateSubCommand.AddOption(updateLabelsOption); updateSubCommand.AddOption(updateAssigneeOption); updateSubCommand.AddOption(updateBranchOption); updateSubCommand.SetHandler((InvocationContext context) => { UpdateTask(context); }); taskCommand.AddCommand(updateSubCommand); var noteSubCommand = new Command("note", Program.GetLocalizedString("TaskNoteSubCommandDescription")); var taskIdArgumentNote = new Argument("task-id", Program.GetLocalizedString("TaskNoteIdArgumentDescription")); var messageOptionNote = new Option(aliases: new[] {"-m", "--message"}, description: Program.GetLocalizedString("TaskNoteMessageOptionDescription")) { IsRequired = true }; noteSubCommand.AddArgument(taskIdArgumentNote); noteSubCommand.AddOption(messageOptionNote); noteSubCommand.SetHandler((string taskId, string message) => { AddNoteToTask(taskId, message); }, taskIdArgumentNote, messageOptionNote); taskCommand.AddCommand(noteSubCommand); var archiveSubCommand = new Command("archive", Program.GetLocalizedString("TaskArchiveSubCommandDescription")); var taskIdArgumentArchive = new Argument("task-id", Program.GetLocalizedString("TaskArchiveIdArgumentDescription")); archiveSubCommand.AddArgument(taskIdArgumentArchive); archiveSubCommand.SetHandler((string taskId) => { ArchiveTask(taskId); }, taskIdArgumentArchive); taskCommand.AddCommand(archiveSubCommand); return taskCommand; } private static void ListTasks( string? filterStatus, string? filterBranch, string? filterAssignee, string? filterPriority, string? filterType, string[]? filterLabels, string? filterDescContains, DateTime? createdAfter, DateTime? createdBefore, DateTime? updatedAfter, DateTime? updatedBefore, DateTime? dueAfter, DateTime? dueBefore, bool includeArchived) { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; Console.WriteLine(Program.GetLocalizedString("TaskListHeader")); var tasks = config.Tasks.AsQueryable(); if (!includeArchived) { tasks = tasks.Where(t => t.Status != TaskStatus.Archived); } if (!string.IsNullOrEmpty(filterStatus)) tasks = tasks.Where(t => t.Status.Equals(filterStatus, StringComparison.OrdinalIgnoreCase)); if (!string.IsNullOrEmpty(filterBranch)) tasks = tasks.Where(t => t.Branch.Equals(filterBranch, StringComparison.OrdinalIgnoreCase)); if (!string.IsNullOrEmpty(filterAssignee)) tasks = tasks.Where(t => t.AssignedTo.Equals(filterAssignee, StringComparison.OrdinalIgnoreCase)); if (!string.IsNullOrEmpty(filterPriority)) tasks = tasks.Where(t => t.Priority != null && t.Priority.Equals(filterPriority, StringComparison.OrdinalIgnoreCase)); if (!string.IsNullOrEmpty(filterType)) tasks = tasks.Where(t => t.Type != null && t.Type.Equals(filterType, StringComparison.OrdinalIgnoreCase)); if (filterLabels != null && filterLabels.Any()) { foreach (var label in filterLabels) { tasks = tasks.Where(t => t.Labels.Contains(label, StringComparer.OrdinalIgnoreCase)); } } if (!string.IsNullOrEmpty(filterDescContains)) tasks = tasks.Where(t => t.Description.Contains(filterDescContains, StringComparison.OrdinalIgnoreCase)); if (createdAfter.HasValue) tasks = tasks.Where(t => t.CreatedAt.Date >= createdAfter.Value.Date); if (createdBefore.HasValue) tasks = tasks.Where(t => t.CreatedAt.Date <= createdBefore.Value.Date); if (updatedAfter.HasValue) tasks = tasks.Where(t => t.UpdatedAt.Date >= updatedAfter.Value.Date); if (updatedBefore.HasValue) tasks = tasks.Where(t => t.UpdatedAt.Date <= updatedBefore.Value.Date); if (dueAfter.HasValue) tasks = tasks.Where(t => t.DueDate.HasValue && t.DueDate.Value.Date >= dueAfter.Value.Date); if (dueBefore.HasValue) tasks = tasks.Where(t => t.DueDate.HasValue && t.DueDate.Value.Date <= dueBefore.Value.Date); var taskList = tasks.ToList(); if (!taskList.Any()) { Console.WriteLine(includeArchived ? Program.GetLocalizedString("TaskListNoTasksFoundIncludingArchived") : Program.GetLocalizedString("TaskListNoActiveTasksFound")); return; } foreach (var task in taskList.OrderByDescending(t => t.UpdatedAt)) { var sb = new StringBuilder(); sb.Append("ID:task.TaskId,−10Branch:task.Branch,−15Status:task.Status,−15");if(!string.IsNullOrEmpty(task.Priority))sb.Append(" Prio: {task.Priority,-8}"); if (!string.IsNullOrEmpty(task.Type)) sb.Append("Type:task.Type,−8");sb.Append(" Desc: {task.Description.Substring(0, Math.Min(task.Description.Length, 25))}..."); Console.WriteLine(sb.ToString()); } } private static void ViewTask(string taskId) { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; var task = config.Tasks.FirstOrDefault(t => t.TaskId == taskId); if (task == null) { Console.Error.WriteLine(Program.GetLocalizedString("TaskViewNotFound", taskId)); return; } Console.WriteLine(Program.GetLocalizedString("TaskViewDetailsTitle", taskId)); Console.WriteLine("Description:task.Description");Console.Write("  Branch: {task.Branch,-15} Status: {task.Status,-15}"); if (!string.IsNullOrEmpty(task.Priority)) Console.Write("Priority:task.Priority,−8");if(!string.IsNullOrEmpty(task.Type))Console.Write(" Type: {task.Type}"); Console.WriteLine(); Console.Write("AssignedTo:task.AssignedTo");if(task.StoryPoints.HasValue)Console.Write(", Story Points: {task.StoryPoints}"); Console.WriteLine(); if (!string.IsNullOrEmpty(task.Sprint)) Console.Write("Sprint:task.Sprint");if(task.DueDate.HasValue)Console.Write("{(string.IsNullOrEmpty(task.Sprint) ? "  " : ", ")}Due Date: {task.DueDate.Value.ToShortDateString()}"); if(!string.IsNullOrEmpty(task.Sprint) || task.DueDate.HasValue) Console.WriteLine(); if (!string.IsNullOrEmpty(task.EpicLink)) Console.WriteLine("EpicLink:task.EpicLink");if(task.Labels.Any())Console.WriteLine("  Labels: {string.Join(", ", task.Labels)}"); Console.WriteLine("  Created: {task.CreatedAt.ToLocalTime()}, Updated: {task.UpdatedAt.ToLocalTime()}"); if (task.RelatedResources.Any()) { Console.WriteLine(Program.GetLocalizedString("TaskViewRelatedResourcesHeader")); foreach(var rr in task.RelatedResources) Console.WriteLine("    - {rr.Path} (Type: {rr.Type}, Action: {rr.Action})"); } if (!string.IsNullOrEmpty(task.HumanNotes)) Console.WriteLine("HumanNotes:Environment.NewLinetask.HumanNotes");if(!string.IsNullOrEmpty(task.AiNotes))Console.WriteLine("  AI Notes: {Environment.NewLine}{task.AiNotes}"); } private static void UpdateTask(InvocationContext context) { var taskId = context.ParseResult.GetValueForArgument(context.Command.Arguments.OfType<Argument>().First(a => a.Name == "task-id")); var config = AIFlowConfigService.LoadConfig(); if (config == null) return; var task = config.Tasks.FirstOrDefault(t => t.TaskId == taskId); if (task == null) { Console.Error.WriteLine(Program.GetLocalizedString("TaskUpdateNotFound", taskId)); return; } bool updated = false; bool IsOptionProvided(Option option) => context.ParseResult.FindResultFor(option) != null; if (IsOptionProvided(updateDescOption)) { task.Description = context.ParseResult.GetValueForOption(updateDescOption) ?? task.Description; updated = true; } if (IsOptionProvided(updateStatusOption)) { task.Status = context.ParseResult.GetValueForOption(updateStatusOption) ?? task.Status; updated = true; } if (IsOptionProvided(updateTypeOption)) { task.Type = context.ParseResult.GetValueForOption(updateTypeOption); updated = true; } if (IsOptionProvided(updateSpOption)) { task.StoryPoints = context.ParseResult.GetValueForOption(updateSpOption); updated = true; } if (IsOptionProvided(updatePriorityOption)) { task.Priority = context.ParseResult.GetValueForOption(updatePriorityOption); updated = true; } if (IsOptionProvided(updateSprintOption)) { task.Sprint = context.ParseResult.GetValueForOption(updateSprintOption); updated = true; } if (IsOptionProvided(updateEpicLinkOption)) { task.EpicLink = context.ParseResult.GetValueForOption(updateEpicLinkOption); updated = true; } if (IsOptionProvided(updateDueDateOption)) { task.DueDate = context.ParseResult.GetValueForOption(updateDueDateOption); updated = true; } if (IsOptionProvided(updateLabelsOption)) { task.Labels = context.ParseResult.GetValueForOption(updateLabelsOption)?.ToList() ?? new List(); updated = true; } if (IsOptionProvided(updateAssigneeOption)) { task.AssignedTo = context.ParseResult.GetValueForOption(updateAssigneeOption) ?? task.AssignedTo; updated = true; } if (IsOptionProvided(updateBranchOption)) { task.Branch = context.ParseResult.GetValueForOption(updateBranchOption) ?? task.Branch; updated = true; } if (updated) { task.UpdatedAt = DateTime.UtcNow; if (AIFlowConfigService.SaveConfig(config)) { Console.WriteLine(Program.GetLocalizedString("TaskUpdateSuccess", taskId)); } else { Console.Error.WriteLine(Program.GetLocalizedString("TaskUpdateFailedSave", taskId)); } } else { Console.WriteLine(Program.GetLocalizedString("TaskUpdateNoChanges", taskId)); } } private static void AddNoteToTask(string taskId, string message) { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; var task = config.Tasks.FirstOrDefault(t => t.TaskId == taskId); if (task == null) { Console.Error.WriteLine(Program.GetLocalizedString("TaskNoteErrorNotFound", taskId)); return; } string formattedNote = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss} - Human]: {message}"; if (string.IsNullOrEmpty(task.HumanNotes)) { task.HumanNotes = formattedNote; } else { task.HumanNotes += Environment.NewLine + Environment.NewLine + formattedNote; } task.UpdatedAt = DateTime.UtcNow; if (AIFlowConfigService.SaveConfig(config)) { Console.WriteLine(Program.GetLocalizedString("TaskNoteAddedSuccess", taskId)); } else { Console.Error.WriteLine(Program.GetLocalizedString("TaskNoteErrorSaving", taskId)); } } private static void ArchiveTask(string taskId) { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; var task = config.Tasks.FirstOrDefault(t => t.TaskId == taskId); if (task == null) { Console.Error.WriteLine(Program.GetLocalizedString("TaskArchiveErrorNotFound", taskId)); return; } if (task.Status == TaskStatus.Archived) { Console.WriteLine(Program.GetLocalizedString("TaskArchiveAlreadyArchived", taskId)); return; } task.Status = TaskStatus.Archived; task.UpdatedAt = DateTime.UtcNow; if (AIFlowConfigService.SaveConfig(config)) { Console.WriteLine(Program.GetLocalizedString("TaskArchiveSuccess", taskId)); } else { Console.Error.WriteLine(Program.GetLocalizedString("TaskArchiveErrorSaving", taskId)); } } } }// --- END CHUNK: Commands/TaskCommand.cs ---// --- START CHUNK: Commands/ResolveCommand.cs ---namespace AIFlow.Cli.Commands { /* ... ResolveCommand code remains the same as v1.7 ... */ using System.CommandLine; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.IO; using System; using System.Linq; public static class ResolveCommand { public static Command Create() { var command = new Command("resolve", Program.GetLocalizedString("ResolveCommandDescription")) { new Argument("resource-path", Program.GetLocalizedString("ResolveResourcePathArgumentDescription")) }; var resourcePathArgument = command.Arguments.OfType<Argument>().First(); command.SetHandler((string resourcePath) => { HandleResolve(resourcePath); }, resourcePathArgument); return command; } private static void HandleResolve(string relativeResourcePath) { var config = AIFlowConfigService.LoadConfig(); if (config == null) return; var normalizedRelativePath = FileService.GetProjectRelativePath(relativeResourcePath); var trackedResource = config.Resources.FirstOrDefault(r => r.Path.Equals(normalizedRelativePath, StringComparison.OrdinalIgnoreCase)); if (trackedResource == null) { Console.Error.WriteLine(Program.GetLocalizedString("ResolveErrorResourceNotFoundInAIFlow", normalizedRelativePath)); return; } if (trackedResource.Status != ResourceStatus.NeedsManualMerge) { Console.WriteLine(Program.GetLocalizedString("ResolveResourceNotMarkedForMerge", normalizedRelativePath, trackedResource.Status)); return; } string fullOriginalPath = FileService.GetFullPath(trackedResource.Path); if (trackedResource.Type == ResourceType.LocalFile && !File.Exists(fullOriginalPath)) { Console.Error.WriteLine(Program.GetLocalizedString("ResolveErrorOriginalFileNotFound", trackedResource.Path)); return; } Console.WriteLine(Program.GetLocalizedString("ResolveConfirmingResolution", trackedResource.Path)); Console.WriteLine(Program.GetLocalizedString("ResolveAssumingUserResolvedInOriginal", trackedResource.Path)); string? newHash = (trackedResource.Type == ResourceType.LocalFile) ? FileService.CalculateFileHash(fullOriginalPath) : trackedResource.LocalHash; if (trackedResource.Type == ResourceType.LocalFile && newHash == null) { Console.Error.WriteLine(Program.GetLocalizedString("ResolveErrorCalculatingNewHash", trackedResource.Path)); return; } if (trackedResource.Type == ResourceType.LocalFile) { string resolvedContent = File.ReadAllText(fullOriginalPath); if (resolvedContent.Contains("<<<<<<<") && resolvedContent.Contains("=======") && resolvedContent.Contains(">>>>>>>")) { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(Program.GetLocalizedString("WarningConflictMarkersStillPresent", trackedResource.Path)); Console.ResetColor(); Console.Write(Program.GetLocalizedString("PromptProceedAnyway")); string? proceed = Console.ReadLine()?.Trim().ToLowerInvariant(); if (proceed != "y") { Console.WriteLine(Program.GetLocalizedString("ResolveAborted")); return; } } } trackedResource.LocalHash = newHash ?? trackedResource.LocalHash; trackedResource.Status = ResourceStatus.Merged; trackedResource.ConflictResolutionFile = null; trackedResource.LastSentToAiHash = null; if (AIFlowConfigService.SaveConfig(config)) { Console.WriteLine(Program.GetLocalizedString("ResolveSuccess", trackedResource.Path, trackedResource.Status)); } else { Console.Error.WriteLine(Program.GetLocalizedString("ResolveErrorSavingConfig", trackedResource.Path)); } } } }// --- END CHUNK: Commands/ResolveCommand.cs ---// --- START CHUNK: Commands/RevertIntegrationCommand.cs ---namespace AIFlow.Cli.Commands { /* ... RevertIntegrationCommand code remains the same ... */ using System.CommandLine; using System.CommandLine.Invocation; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.Linq; using System; public static class RevertIntegrationCommand { static Option listOption = new Option(aliases: new[] { "--list", "-l" }, description: Program.GetLocalizedString("RevertListOptionDescription")); static Option<string?> idOption = new Option<string?>(aliases: new[] { "--id" }, description: Program.GetLocalizedString("RevertIdOptionDescription")); static Option lastOption = new Option(aliases: new[] { "--last" }, description: Program.GetLocalizedString("RevertLastOptionDescription")); static Option forceOption = new Option(aliases: new[] { "--force", "-f" }, description: Program.GetLocalizedString("RevertForceOptionDescription")); public static Command Create() { var command = new Command("revert", Program.GetLocalizedString("RevertCommandDescription")); command.AddOption(listOption); command.AddOption(idOption); command.AddOption(lastOption); command.AddOption(forceOption); command.SetHandler((InvocationContext context) => { var list = context.ParseResult.GetValueForOption(listOption); var backupId = context.ParseResult.GetValueForOption(idOption); var useLast = context.ParseResult.GetValueForOption(lastOption); var force = context.ParseResult.GetValueForOption(forceOption); HandleRevert(list, backupId, useLast, force); }); return command; } private static void HandleRevert(bool list, string? backupId, bool useLast, bool force) { if (list) { ListAvailableBackups(); return; } string? targetBackupId = null; var availableBackups = BackupService.ListBackups(); if (useLast) { targetBackupId = availableBackups.FirstOrDefault()?.BackupId; if (targetBackupId == null) { Console.Error.WriteLine(Program.GetLocalizedString("RevertErrorNoBackupsFound")); return; } Console.WriteLine(Program.GetLocalizedString("RevertSelectedLastBackup", targetBackupId)); } else if (!string.IsNullOrEmpty(backupId)) { if (availableBackups.Any(b => b.BackupId == backupId)) { targetBackupId = backupId; } else { Console.Error.WriteLine(Program.GetLocalizedString("RevertErrorSpecificBackupNotFound", backupId)); ListAvailableBackups(); return; } } else { Console.Error.WriteLine(Program.GetLocalizedString("RevertSpecifyIdOrLast")); ListAvailableBackups(); return; } if (targetBackupId == null) return; Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine(Program.GetLocalizedString("RevertWarning", targetBackupId)); Console.ResetColor(); if (!force) { Console.Write(Program.GetLocalizedString("PromptConfirmRevert")); string? confirm = Console.ReadLine()?.Trim().ToLowerInvariant(); if (confirm != "yes") { Console.WriteLine(Program.GetLocalizedString("RevertAbortedByUser")); return; } } if (BackupService.RestoreBackup(targetBackupId)) { Console.WriteLine(Program.GetLocalizedString("RevertSuccess", targetBackupId)); } else { Console.Error.WriteLine(Program.GetLocalizedString("RevertFailed", targetBackupId)); } } private static void ListAvailableBackups() { var backups = BackupService.ListBackups(); if (!backups.Any()) { Console.WriteLine(Program.GetLocalizedString("RevertNoBackupsAvailable")); return; } Console.WriteLine(Program.GetLocalizedString("RevertAvailableBackupsHeader")); foreach (var backup in backups) { Console.WriteLine($"  ID: {backup.BackupId,-20} Timestamp: {backup.TimestampUtc.ToLocalTime(),-25} Task: {backup.RelatedTaskId ?? "N/A",-15} Notes: {backup.Notes}"); } } } }// --- END CHUNK: Commands/RevertIntegrationCommand.cs ---// --- START CHUNK: Commands/SummaryCommand.cs ---namespace AIFlow.Cli.Commands { /* ... SummaryCommand code remains the same as v1.7 ... */ using System.CommandLine; using AIFlow.Cli.Models; using AIFlow.Cli.Services; using System.Linq; using System.Text; using System; using System.IO; public static class SummaryCommand { public static Command Create() { var command = new Command("summary", Program.GetLocalizedString("SummaryCommandDescription")); command.SetHandler(() => HandleSummary()); return command; } private static void HandleSummary() { var config = AIFlowConfigService.LoadConfig(); if (config == null) { Console.Error.WriteLine(Program.GetLocalizedString("ErrorConfigNotLoadedForSummary")); return; } Console.WriteLine(Program.GetLocalizedString("SummaryHeader")); Console.WriteLine("--------------------------------------------------"); Console.WriteLine(Program.GetLocalizedString("SummaryProjectInfo", config.ProjectName, config.CurrentBranch)); Console.WriteLine(); Console.WriteLine(Program.GetLocalizedString("SummaryTaskOverviewHeader")); var activeTasks = config.Tasks.Where(t => t.Status != TaskStatus.Archived).ToList(); Console.WriteLine(Program.GetLocalizedString("SummaryTotalActiveTasks", activeTasks.Count)); var taskStatusCounts = activeTasks.GroupBy(t => t.Status).Select(g => new { Status = g.Key, Count = g.Count() }).OrderBy(s => s.Status).ToList(); if (taskStatusCounts.Any()) { foreach (var statusCount in taskStatusCounts) { Console.WriteLine($"  - {statusCount.Status}: {statusCount.Count}"); } } else { Console.WriteLine(Program.GetLocalizedString("SummaryNoActiveTasksToSummarize")); } var overdueTasksCount = activeTasks.Count(t => t.DueDate.HasValue && t.DueDate.Value.Date < DateTime.UtcNow.Date && t.Status != TaskStatus.Done && t.Status != TaskStatus.Completed); Console.WriteLine(Program.GetLocalizedString("SummaryOverdueTasksCount", overdueTasksCount)); Console.WriteLine(); Console.WriteLine(Program.GetLocalizedString("SummaryResourceStatusHeader")); int awaitingAiChangesCount = config.Resources.Count(r => r.Status == ResourceStatus.AwaitingAiChanges); int needsManualMergeCount = config.Resources.Count(r => r.Status == ResourceStatus.NeedsManualMerge); int unmanagedLocalChangesCount = 0; foreach (var resource in config.Resources) { if (resource.Type == ResourceType.LocalFile && !(resource.Status == ResourceStatus.AiModified || resource.Status == ResourceStatus.NeedsManualMerge || resource.Status == ResourceStatus.Merged || resource.Status == ResourceStatus.AwaitingAiChanges)) { string currentDiskHash = FileService.CalculateFileHash(FileService.GetFullPath(resource.Path)) ?? "Missing"; if (currentDiskHash != "Missing" && !string.IsNullOrEmpty(resource.LocalHash) && resource.LocalHash != currentDiskHash) { unmanagedLocalChangesCount++; } } } Console.WriteLine(Program.GetLocalizedString("SummaryResourcesAwaitingAI", awaitingAiChangesCount)); Console.WriteLine(Program.GetLocalizedString("SummaryResourcesNeedMerge", needsManualMergeCount)); Console.WriteLine(Program.GetLocalizedString("SummaryResourcesUnmanagedChanges", unmanagedLocalChangesCount)); Console.WriteLine(); if (config.ActiveAiRetrievalSession != null) { Console.WriteLine(Program.GetLocalizedString("SummaryActiveRetrievalHeader")); Console.WriteLine(Program.GetLocalizedString("SummaryActiveRetrievalDetails", config.ActiveAiRetrievalSession.ReceivedBatchesCount, config.ActiveAiRetrievalSession.TotalBatches, config.ActiveAiRetrievalSession.RetrievalGuid)); Console.WriteLine(); } Console.WriteLine(Program.GetLocalizedString("SummaryUpcomingDueDatesHeader")); var upcomingTasks = activeTasks.Where(t => t.DueDate.HasValue && t.DueDate.Value.Date >= DateTime.UtcNow.Date).OrderBy(t => t.DueDate.Value).Take(3).ToList(); if (upcomingTasks.Any()) { foreach (var task in upcomingTasks) { Console.WriteLine(Program.GetLocalizedString("SummaryUpcomingTaskEntry", task.DueDate.Value.ToShortDateString(), task.TaskId, task.Description.Substring(0, Math.Min(task.Description.Length, 40)))); } } else { Console.WriteLine(Program.GetLocalizedString("SummaryNoUpcomingDueDates")); } Console.WriteLine("--------------------------------------------------"); } } }// --- END CHUNK: Commands/SummaryCommand.cs ---// --- START CHUNK: Properties/Resources.resx.txt ---AIFlow CLI - Manages collaborative workflows with AI.Initializes a new AIFlow project in the current directory.Initializing AIFlow project...AIFlow project already exists ('{0}' found).AIFlow project initialized. '{0}' created.Failed to initialize AIFlow project.Default branch for new tasks is 'develop'. Use 'aiflow-cli checkout ' to change.# AIFlow Ignore FileLines starting with # are comments.Add file paths or glob patterns to exclude from AI requests.Examples:Ignore all log files*.logIgnore a specific directory and its contentsnode_modules/.DS_StoreIgnore sensitive configurationconfig/local_secrets.jsonAIFlow's own backup directory (already a default internal ignore).aiflow_backups/Sample '{0}' file created. You can edit it to specify files/patterns to exclude from AI requests.Error creating sample '{0}' file: {1}Prepares a request package for the AI based on a task description and specified resources.Optional: Existing Task ID to update or add resources to.Task description for the AI. Required if not updating an existing task with --task-id.Resource(s) (e.g., file paths) to include/update in the request. Can be specified multiple times.New resource(s) for the AI to create (e.g., file paths). Can be specified multiple times.Warning: Resource '{0}' matches an ignore pattern in '{1}' and will be excluded from the AI request.Warning: Path for new resource '{0}' matches an ignore pattern in '{1}'. This new resource will not be requested from the AI.Error: Resource not found: {0}CONFLICT: Resource '{0}' has been modified locally since it was prepared for the AI.Local Disk Hash: {1}Sent to AI Hash: {2}AI Based its Changes On Hash: {3}Skipped AI changes for '{0}'. Local version preserved. Resource status set to '{1}'.Resource deleted: {0}Skipping resource '{0}' in AI response as no content was provided.[DRY RUN] Would delete resource: {0}[DRY RUN] Would create resource: {0}[DRY RUN] Would update resource: {0}[DRY RUN] Would add new resource to tracking: {0}Resource created: {0}Resource updated: {0}Resource reference updated for '{0}' (Type: {1}).Tracked Resources:  No resources are currently tracked.  MODIFIED: {0} (Disk Hash: {1}..., Stored Hash: {2}...)  Related Resources:The path to the original resource that had conflicts (e.g., 'src/app.js').Error: Resource '{0}' is not tracked by AIFlow or not found in aiflow.json.Resource '{0}' is not currently marked as '{1}'. No resolution needed via this command.Name of the flow template to use for initialization.Path to the AIFlow templates JSON file (default: aiflow_templates.json).Error: Template file '{0}' not found.Error: Template '{0}' not found in template file '{1}'.Template not applied. Falling back to default project initialization.Successfully applied template '{0}' to the new AIFlow project.Created placeholder resource: {0}Error creating placeholder resource '{0}': {1}Error processing template file '{0}': {1}Enter resources to include/update (e.g., file paths; one per line, press Enter on empty line to finish)Resource path to include/updateEnter new resources for AI to create (e.g., file paths; one per line, press Enter on empty line to finish)New resource pathResource Status:  Resources Awaiting AI Changes: {0}  Resources Needing Manual Merge: {0}  Resources with Unmanaged Local Changes: {0}Task ID to continue preparing input for (if a previous request for this task was split).Optional: Type of the task (e.g., Story, Task, Bug). If omitted, no type is set.Invalid task type '{0}'. Valid types are: {1}.Story points for the task (integer).Optional: Priority of the task (e.g., High, Medium, Low). If omitted, no priority is set.Invalid task priority '{0}'. Valid priorities are: {1}.Sprint identifier for the task.Task ID of the parent Epic.Due date for the task (e.g., yyyy-MM-dd).Labels/tags for the task. Can be specified multiple times.Assignee for the task (e.g., 'ai', 'human/john.doe'). Default: ai.Assign this task to a specific branch (overrides current checked-out branch for this task).Additional notes for the AI for this task.Error: Either --task-id or --task-desc must be provided.Error: --task-desc is required when --task-id is not provided or does not match an existing task.AI Request Package (copy and paste to AI):This request has been split. Send the above part to the AI. Then run: aiflow-cli prepare-input --continue-task {0}All parts for task '{0}' sent. Awaiting AI processing.Error: Task ID '{0}' not found or not in a state to continue split request.Error: Task '{0}' is not pending more input parts or all parts already sent.Continuing split request for Task ID '{0}'. Preparing part {1} of {2} (approx).Info: This request is large and will be split. Human Request Group ID: {0}.Warning: The prepared request (Task: {2}, Part: {3}) is estimated to be ~{0} tokens. This may exceed the AI's configured context limit of {1} tokens. Consider reducing file content, splitting the task further, or being more concise in descriptions/notes.Info: Estimated token count for this request part ({1}) is ~{0} tokens.--- AIFlow: Prepare Input (Interactive Mode) ---Enter task description--- Optional Agile Metadata ---Task Type (e.g., {0})Story Points (integer)Task Priority (e.g., {0})Sprint IdentifierParent Epic Task IDDue DateEnter labels (one per line, press Enter on empty line to finish)LabelAssigneeBranch for this taskAdditional notes for the AI (optional)(Press Enter on an empty line to finish)Integrates an output package (JSON) received from the AI.The JSON payload received from the AI.Simulate integration without making any actual changes to files or aiflow.json.Error parsing AI JSON: {0}Error: The provided AI JSON does not match any known AIFlow output structures.Error: The AI response is not valid JSON. Details: {0}Error: The AI response is valid JSON, but does not seem to be a recognized AIFlow output package. It might be missing key AIFlow structures or have an unexpected format.Error: The AI response is valid JSON, but it does not appear to be an AIFlow formatted response (e.g., missing 'aiChangesetId', 'fileChanges', or known wrapper objects).AI indicates its output is large and will be sent in {0} batches. Retrieval ID: {1}Run 'aiflow-cli fetch-output --retrieval-id {0} --batch {1}' to get instructions for the AI.Error: Task not found for AI response (Task ID/HumanRequestID: {0}).Received batch {0} of {1} for retrieval ID '{2}'.All batches received for retrieval ID '{0}'. Processing...Task '{0}' updated. New status: {1}CONFLICT: File '{0}' has been modified locally since it was prepared for the AI.Local Disk Hash: {1}Sent to AI Hash: {2}AI Based its Changes On Hash: {3}For file '{0}': (O)verwrite local, (S)kip AI's changes, or (M)erge (writes conflict markers to original file)? [O/S/M]: Skipped AI changes for '{0}'. Local version preserved. File status set to '{1}'.Git-style merge conflict markers have been written directly into '{0}'.Please open '{0}' in your editor, resolve the conflicts (your Git merge tool should recognize it), save the file, then run 'aiflow-cli resolve "{0}"'Error writing merge markers to '{0}': {1}. File status set to NeedsManualMerge.Warning: For file '{0}', AI based its changes on hash {1}, but the version sent for this task was {2}. Applying AI changes.Error writing file '{0}': {1}Task '{0}' status adjusted to '{1}' because some AI file changes were skipped or require manual merge.AI output integrated successfully.AI output processed. No file changes were applied (either no changes from AI or all changes skipped/merged without direct application).*** DRY RUN MODE ACTIVE: No changes will be made. [DRY RUN] Would delete file: {0}[DRY RUN] Would create file: {0}[DRY RUN] Would update file: {0}[DRY RUN] Conflict detected for '{0}'. You would be prompted to (O)verwrite, (S)kip, or (M)erge.[DRY RUN] Simulating user choice: Overwrite for '{0}'.[DRY RUN] Simulating user choice: Skip for '{0}'.[DRY RUN] Simulating user choice: Merge for '{0}'. Original file would be updated with conflict markers.[DRY RUN] Would update Task '{0}': Status to '{1}', AI Notes: '{2}'[DRY RUN] Task '{0}' status would be adjusted to '{1}' due to skipped/merged files.[DRY RUN] Would save changes to aiflow.json.[DRY RUN] Summary: Changes would be applied as detailed above.[DRY RUN] Summary: No changes would be applied based on AI output. DRY RUN MODE ENDED. **[DRY RUN] Would update active AI retrieval session in aiflow.json.[DRY RUN] Would save aiflow.json to update batch retrieval status.[DRY RUN] Would clear active AI retrieval session from aiflow.json after processing all batches.[DRY RUN] Would add new file to tracking: {0}[DRY RUN] Would create a backup of current state before applying changes.Provides instructions to ask the AI for a specific batch of a large AI output.The retrieval ID provided by the AI for batched output.The batch number to fetch.To fetch the AI output batch, please send the following message to the AI:AIFlow CLI Request: Provide batch {0} for retrievalId {1}Then, use 'aiflow-cli integrate-output "[AI_JSON_RESPONSE_FOR_BATCH]"' to integrate the received batch.Warning: No active AI retrieval session found for ID '{0}' in aiflow.json. Proceeding with instruction generation.Shows the current status of the AIFlow project.Show detailed task information.Include archived tasks in the status task list.Project: {0}Current Branch: {0}Unmanaged Local Changes (modified since last AIFlow operation, not part of current AI tasks):  No unmanaged local file changes detected.  MODIFIED: {0} (Disk Hash: {1}..., Stored Hash: {2}...)Overdue Tasks (Due date passed, not Done/Completed/Archived):  No overdue tasks.  ID: {0,-10} Due: {1,-12} Branch: {2,-15} Desc: {3}...Tasks:  No tasks found.  No active tasks found (excluding archived).  No tasks found (including archived).Task Status Summary:  {0}: {1}  No tasks to summarize.Active AI Retrieval Session: ID {0}, Received {1}/{2} batches.Manages task branches. List branches or create a new one conceptually.Name of the branch to create/show. If omitted, lists existing branches.Existing branches (derived from tasks, '' indicates current):Branch '{0}' noted. New tasks can now be assigned to this branch. Use 'checkout' to switch the active branch.Tip: For GitFlow style, consider prefixes like 'feature/', 'bugfix/', 'release/', 'hotfix/' for branch '{0}'.Use 'aiflow-cli checkout {0}' to make this the active branch for new tasks.Branch deletion is conceptual in AIFlow (branches exist if tasks reference them). No direct delete action.Switches the current active branch for new tasks.Name of the branch to switch to.Switched to branch '{0}'.Failed to switch to branch '{0}'.Manage AIFlow tasks (list, view, update metadata, add notes, archive).List tasks, optionally filtered.Filter tasks by status (e.g., todo, in_progress, done).Filter tasks by branch name.Filter tasks by assignee (case-insensitive).Filter tasks by priority (e.g., High, Medium, Low; case-insensitive).Filter tasks by type (e.g., Story, Bug, Task; case-insensitive).Filter tasks by label (case-insensitive). Can be specified multiple times (AND logic).Filter tasks whose description contains the specified text (case-insensitive).Filter tasks created on or after this date (YYYY-MM-DD).Filter tasks created on or before this date (YYYY-MM-DD).Filter tasks updated on or after this date (YYYY-MM-DD).Filter tasks updated on or before this date (YYYY-MM-DD).Filter tasks due on or after this date (YYYY-MM-DD).Filter tasks due on or before this date (YYYY-MM-DD).Include archived tasks in the list.AIFlow Tasks:  No tasks found matching criteria.  No active tasks found matching criteria (excluding archived).  No tasks found matching criteria (including archived).View detailed information for a specific task.The ID of the task to view.Error: Task with ID '{0}' not found.Details for Task '{0}':Update metadata of an existing task.The ID of the task to update.Error: Task with ID '{0}' not found for update.Task '{0}' updated successfully.Error: Task '{0}' was updated in memory, but failed to save to aiflow.json.No changes specified for task '{0}'.New description for the task.New status for the task (e.g., todo, in_progress, done).Optional: New type for the task. Clears type if value is empty and option is present.New story points for the task.Optional: New priority for the task. Clears priority if value is empty and option is present.New sprint identifier for the task.New parent Epic Task ID.New due date for the task (YYYY-MM-DD).New set of labels for the task (replaces existing). Can be specified multiple times.New assignee for the task.Move task to a different branch.Add a human-authored note to an existing task.The ID of the task to add a note to.The content of the note/comment to add.Error: Task with ID '{0}' not found. Cannot add note.Note added successfully to task '{0}'.Error saving note for task '{0}'.Archive a task, hiding it from default lists.The ID of the task to archive.Error: Task with ID '{0}' not found. Cannot archive.Task '{0}' is already archived.Task '{0}' archived successfully.Error saving archive status for task '{0}'.Marks a file with merge conflicts as resolved after manual editing.The path to the original resource that had conflicts (e.g., 'src/app.js').Error: Resource '{0}' is not tracked by AIFlow or not found in aiflow.json.Resource '{0}' is not currently marked as '{1}'. No resolution needed via this command.Error: The original file '{0}' could not be found on disk to calculate its new hash.Assuming you have manually resolved conflicts directly in '{0}' and saved it.Warning: File '{0}' still appears to contain Git conflict markers (<<<<<<<, =======, >>>>>>>).Are you sure you want to mark it as resolved? (y/n): Resolution aborted by user.Error: Could not calculate the hash of the resolved file '{0}'. Resolution aborted.File '{0}' marked as resolved. New status: {1}. Please review and commit if using Git.Conflict marker file '{0}' has been deleted.Error deleting conflict marker file '{0}': {1}. Please delete it manually.Error saving AIFlow configuration after resolving '{0}'.Confirming resolution for file: {0}Reverts the project state (aiflow.json and affected files) to a previous backup.List available backups.The ID (timestamp string) of the backup to revert to.Revert to the most recent backup.Force revert without confirmation prompt.Error: No backups found to revert to the last one.Selected last backup: {0}Error: Backup with ID '{0}' not found.Please specify a backup ID with --id or use --last. Use --list to see available backups.No backups available to list or revert.Available Backups (most recent first):WARNING: This will overwrite your current aiflow.json and any files included in backup ID '{0}' with their backed-up versions. This operation cannot be easily undone unless you manually back up first.Are you sure you want to proceed with the revert? Type 'yes' to confirm: Revert aborted by user.Error: Backup directory or info file for ID '{0}' not found.Error: Could not read or parse backup information for ID '{0}'.Restored '{0}' from backup ID '{1}'.Warning: File '{0}' listed in backup info for ID '{1}' was not found in the backup files directory.Successfully restored project state from backup ID '{0}'.Please review the restored files. You may want to run 'aiflow-cli status'. If using Git, check 'git status'.An error occurred during the restore from backup ID '{0}': {1}Error reading backup info for '{0}': {1}Backup created successfully with ID '{0}' at: {1}Error creating backup '{0}': {1}Warning: Backup creation failed. Proceeding with integration without a backup.Proceed with integration without a backup? (y/n): Integration aborted by user.Display a high-level summary of the AIFlow project.Error: AIFlow configuration could not be loaded. Cannot display summary. Run 'aiflow-cli init'.AIFlow Project SummaryProject: {0}   |   Current Branch: {1}Task Overview:  Total Active Tasks: {0}  No active tasks to summarize.  Overdue Active Tasks: {0}File Status:  Files Awaiting AI Changes: {0}  Files Needing Manual Merge: {0}  Files with Unmanaged Local Changes: {0}Active AI Retrieval:  Fetching batch {0} of {1} for AI Changeset ID (Retrieval GUID: {2}).Upcoming Due Dates (Next 3 Active Tasks):  {0}: {1} - {2}...  No active tasks with upcoming due dates.Error decoding Base64 string: {0}An unexpected error occurred: {0}Error: Configuration file '{0}' not found in '{1}'. Run 'aiflow-cli init' to create one.Error reading or parsing '{0}': {1}Error saving '{0}': {1}Error: File not found for hashing: {0}Error calculating hash for file '{0}': {1}// --- END CHUNK: Properties/Resources.resx.txt ---// --- START CHUNK: aiflow_templates.json.txt ---{"Templates": [{"Name": "FamilyChores","Description": "A simple system to manage weekly family chores.","ConfigOverrides": {"ApproxMaxAiContextTokens": 4000},"InitialTasks": [{"TaskId": "chore_define","Description": "Define all weekly chores and who is responsible for what. Create initial schedule.","Type": "Task","Priority": "Highest","Status": "todo","AssignedTo": "human","Labels": ["planning", "setup"],"RelatedResources": [{ "Path": "chore_list.md", "Type": "LocalFile", "Action": "create" },{ "Path": "weekly_schedule.md", "Type": "LocalFile", "Action": "create" }]},{"Description": "Ask AI to refine the weekly schedule for fairness and age-appropriateness.","Type": "Task","Priority": "High","Status": "todo","AssignedTo": "ai","RelatedResources": [{ "Path": "weekly_schedule.md", "Type": "LocalFile", "Action": "update"}]},{"Description": "Review and finalize the AI-suggested chore schedule.","Type": "Task","Status": "todo","AssignedTo": "human"}],"InitialResources": [{"Path": "chore_list.md","Type": "LocalFile","InitialContent": "# Family Chores List\n\n- Dishwasher (load/unload)\n- Trash & Recycling (take out)\n- Walk the dog\n- Clean bathroom\n- Vacuum living room\n- Kids: Tidy their rooms\n- Kids: Feed pets\n"},{"Path": "weekly_schedule.md","Type": "LocalFile","InitialContent": "# Weekly Chore Schedule\n\nTo be defined and then refined by AI.\n"}],"InitialRoadmap": ["Implement daily chore check-offs","Consider a reward system"]},{"Name": "HouseMaintenance","Description": "Track and manage house maintenance tasks.","InitialTasks": [{"Description": "Compile list of all major appliances and systems with their manuals and last service dates.","Type": "Task", "Priority": "High", "Status": "todo", "AssignedTo": "human","RelatedResources": [{ "Path": "maintenance_log.md", "Type": "LocalFile", "Action": "create" }]},{"Description": "Research and schedule annual HVAC servicing.","Type": "Task", "Priority": "Medium", "Status": "todo", "AssignedTo": "human", "DueDate": "2025-09-01"},{"Description": "Ask AI to generate a seasonal maintenance checklist based on local climate (e.g., Michigan).","Type": "Task", "Priority": "Medium", "Status": "todo", "AssignedTo": "ai","RelatedResources": [{ "Path": "seasonal_checklist.md", "Type": "LocalFile", "Action": "create" }]}],"InitialResources": [{"Path": "maintenance_log.md","Type": "LocalFile","InitialContent": "# House Maintenance Log\n\n| Item          | Manual Link | Last Service | Next Due   |\n|---------------|-------------|--------------|------------|\n| HVAC          |             |              |            |\n| Water Heater  |             |              |            |\n| Smoke Detectors |             | (test date)  | (test date)|\n"}],"InitialRoadmap": ["Log all filter replacement dates","Get quotes for gutter cleaning"]},{"Name": "CarShopping","Description": "A flow for researching and comparing new cars.","InitialTasks": [{"Description": "Define primary car requirements (budget, size, type, key features).","Type": "Task", "Priority": "Highest", "Status": "todo", "AssignedTo": "human","RelatedResources": [{ "Path": "car_requirements.md", "Type": "LocalFile", "Action": "create" }]},{"Description": "Identify 3-5 potential car models based on requirements.","Type": "Task", "Priority": "High", "Status": "todo", "AssignedTo": "human","RelatedResources": [{ "Path": "car_shortlist.md", "Type": "LocalFile", "Action": "create" }]},{"Description": "Ask AI to compare shortlisted cars on safety, MPG, and reliability using data from their official websites or reputable review sites (provide links in car_shortlist.md). Summarize in comparison_table.md.","Type": "Task", "Priority": "High", "Status": "todo", "AssignedTo": "ai","RelatedResources": [{ "Path": "car_shortlist.md", "Type": "LocalFile", "Action": "update" },{ "Path": "comparison_table.md", "Type": "LocalFile", "Action": "create" }]},{"Description": "Schedule test drives for top 2 choices.","Type": "Task", "Priority": "Medium", "Status": "todo", "AssignedTo": "human"}],"InitialResources": [{"Path": "car_requirements.md","Type": "LocalFile","InitialContent": "# New Car Requirements\n\n- Budget: \n- Type: (SUV, Sedan, Hatchback, etc.)\n- Seats: \n- Must-have Features: \n- Nice-to-have Features: \n"},{"Path": "car_shortlist.md","Type": "LocalFile","InitialContent": "# Car Shortlist\n\n1. [Make Model Year] - [Link to official page or review]\n2. ...\n3. ...\n"}],"InitialRoadmap": ["Research insurance quotes","Investigate financing options"]}]}// --- END CHUNK: aiflow_templates.json.txt ---